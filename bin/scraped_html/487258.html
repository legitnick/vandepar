<!DOCTYPE html><html lang="en"><head><style>@import url("https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;1,200;1,300&family=Work+Sans:wght@400;500&display=swap");</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><head><link href="../../src/css/general.css" rel="stylesheet" /></head><p class='question-hyperlink'>What is a plain English explanation of &quot;Big O&quot; notation?</p><div class="s-prose js-post-body"><p>I'd prefer as little formal definition as possible and simple mathematics.</p>
</div><p class="this-has-helped">This answer has helped 7051 people.</p><div class="s-prose js-post-body"><p>Quick note, my answer is almost certainly confusing <a href="http://en.wikipedia.org/wiki/Big_O_notation" rel="noreferrer">Big Oh notation</a> (which is an upper bound) with Big Theta notation &quot;Θ&quot; (which is a two-side bound). But in my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</p>
<hr />
<p>BigOh complexity can be visualized with this graph:</p>
<p><a href="https://i.stack.imgur.com/WcBRI.png" rel="noreferrer"><img src="https://i.stack.imgur.com/WcBRI.png" alt="Big Oh Analysis" /></a></p>
<p>The simplest definition I can give for Big Oh notation is this:</p>
<p><strong>Big Oh notation is a relative representation of the complexity of an algorithm.</strong></p>
<p>There are some important and deliberately chosen words in that sentence:</p>
<blockquote>
<ul>
<li><strong>relative:</strong> you can only compare apples to apples.  You can't compare an algorithm that does arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</li>
<li><strong>representation:</strong> BigOh (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if the comparison is cheap but swapping is expensive?  It changes the comparison; and</li>
<li><strong>complexity:</strong> if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</li>
</ul>
</blockquote>
<p>Come back and reread the above when you've read the rest.</p>
<p>The best example of BigOh I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learned in school were:</p>
<blockquote>
<ul>
<li>addition;</li>
<li>subtraction;</li>
<li>multiplication; and</li>
<li>division.</li>
</ul>
</blockquote>
<p>Each of these is an operation or a problem.  A method of solving these is called an <strong>algorithm</strong>.</p>
<p>The addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</p>
<p>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add <strong>two</strong> 10,000 digit numbers we have to do 10,000 additions.</p>
<p>See the pattern?  The <strong>complexity</strong> (being the number of operations) is directly proportional to the number of digits <em>n</em> in the larger number.  We call this <strong>O(n)</strong> or <strong>linear complexity</strong>.</p>
<p>Subtraction is similar (except you may need to borrow instead of carry).</p>
<p>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</p>
<p>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10<sup>12</sup>) multiplications and two million adds.</p>
<p>As the algorithm scales with n-<em>squared</em>, this is <strong>O(n<sup>2</sup>)</strong> or <strong>quadratic complexity</strong>. This is a good time to introduce another important concept:</p>
<p><strong>We only care about the most significant portion of complexity.</strong></p>
<p>The astute may have realized that we could express the number of operations as: n<sup>2</sup> + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</p>
<p>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big Oh notation is about the Worst-case scenario of an algorithm.</p>
<h1>The Telephone Book</h1>
<p>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</p>
<p>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</p>
<p>A typical implementation might be to open up to the middle, take the 500,000<sup>th</sup> and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got really lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</p>
<p>This is called a <strong>binary search</strong> and is used every day in programming whether you realize it or not.</p>
<p>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</p>
<blockquote>
<ul>
<li>For a phone book of 3 names it takes 2 comparisons (at most).</li>
<li>For 7 it takes at most 3.</li>
<li>For 15 it takes 4.</li>
<li>…</li>
<li>For 1,000,000 it takes 20.</li>
</ul>
</blockquote>
<p>That is staggeringly good, isn't it?</p>
<p>In BigOh terms this is <strong>O(log n)</strong> or <strong>logarithmic complexity</strong>.  Now the logarithm in question could be ln (base e), log<sub>10</sub>, log<sub>2</sub> or some other base.  It doesn't matter it's still O(log n) just like O(2n<sup>2</sup>) and O(100n<sup>2</sup>) are still both O(n<sup>2</sup>).</p>
<p>It's worthwhile at this point to explain that BigOh can be used to determine three cases with an algorithm:</p>
<blockquote>
<ul>
<li><strong>Best Case:</strong> In the telephone book search, the best case is that we find the name in one comparison.  This is <strong>O(1)</strong> or <strong>constant complexity</strong>;</li>
<li><strong>Expected Case:</strong> As discussed above this is O(log n); and</li>
<li><strong>Worst Case:</strong> This is also O(log n).</li>
</ul>
</blockquote>
<p>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</p>
<p>Back to the telephone book.</p>
<p>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</p>
<p>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is <strong>unordered</strong> (by phone number anyway).</p>
<p>So to find a name given the phone number (reverse lookup):</p>
<blockquote>
<ul>
<li><strong>Best Case:</strong> O(1);</li>
<li><strong>Expected Case:</strong> O(n) (for 500,000); and</li>
<li><strong>Worst Case:</strong> O(n) (for 1,000,000).</li>
</ul>
</blockquote>
<h1>The Traveling Salesman</h1>
<p>This is quite a famous problem in computer science and deserves a mention.  In this problem, you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</p>
<p>Sounds simple?  Think again.</p>
<p>If you have 3 towns A, B, and C with roads between all pairs then you could go:</p>
<blockquote>
<ul>
<li>A → B → C</li>
<li>A → C → B</li>
<li>B → C → A</li>
<li>B → A → C</li>
<li>C → A → B</li>
<li>C → B → A</li>
</ul>
</blockquote>
<p>Well, actually there's less than that because some of these are equivalent (A → B → C and C → B → A are equivalent, for example, because they use the same roads, just in reverse).</p>
<p>In actuality, there are 3 possibilities.</p>
<blockquote>
<ul>
<li>Take this to 4 towns and you have (iirc) 12 possibilities.</li>
<li>With 5 it's 60.</li>
<li>6 becomes 360.</li>
</ul>
</blockquote>
<p>This is a function of a mathematical operation called a <strong>factorial</strong>.  Basically:</p>
<blockquote>
<ul>
<li>5! = 5 × 4 × 3 × 2 × 1 = 120</li>
<li>6! = 6 × 5 × 4 × 3 × 2 × 1 = 720</li>
<li>7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040</li>
<li>…</li>
<li>25! = 25 × 24 × … × 2 × 1 = 15,511,210,043,330,985,984,000,000</li>
<li>…</li>
<li>50! = 50 × 49 × … × 2 × 1 = 3.04140932 × 10<sup>64</sup></li>
</ul>
</blockquote>
<p>So the BigOh of the Traveling Salesman problem is <strong>O(n!)</strong> or <strong>factorial or combinatorial complexity</strong>.</p>
<p><strong>By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.</strong></p>
<p>Something to think about.</p>
<h1>Polynomial Time</h1>
<p>Another point I wanted to make a quick mention of is that any algorithm that has a complexity of <strong>O(n<sup>a</sup>)</strong> is said to have <strong>polynomial complexity</strong> or is solvable in <strong>polynomial time</strong>.</p>
<p>O(n), O(n<sup>2</sup>) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" rel="noreferrer">Public Key Cryptography</a> is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</p>
<p>Anyway, that's it for my (hopefully plain English) explanation of BigOh (revised).</p>
</div><p class="this-has-helped">This answer has helped 800 people.</p><div class="s-prose js-post-body"><p>It shows how an algorithm scales based on input size.</p>
<p><strong>O(n<sup>2</sup>)</strong>:  known as <strong>Quadratic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 100 operations</li>
<li>100 items: 10,000 operations</li>
</ul>
<p>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10<sup>2</sup>. Basically, n=10 and so O(n<sup>2</sup>) gives us the scaling factor n<sup>2</sup> which is 10<sup>2</sup>.</p>
<p><strong>O(n)</strong>:  known as <strong>Linear complexity</strong></p>
<ul>
<li>1 item: 1 operation</li>
<li>10 items: 10 operations</li>
<li>100 items: 100 operations</li>
</ul>
<p>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</p>
<p><strong>O(1)</strong>:  known as <strong>Constant complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 1 operations</li>
<li>100 items: 1 operations</li>
</ul>
<p>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</p>
<p><strong>O(log n)</strong>:  known as <strong>Logarithmic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 2 operations</li>
<li>100 items: 3 operations</li>
<li>1000 items: 4 operations</li>
<li>10,000 items: 5 operations</li>
</ul>
<p>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input <code>n</code> is the time required, hence <code>log n</code>.</p>
<p>That's the gist of it. They reduce the maths down so it might not be exactly n<sup>2</sup> or whatever they say it is, but that'll be the dominating factor in the scaling.</p>
</div><p class="this-has-helped">This answer has helped 443 people.</p><div class="s-prose js-post-body"><p>Big-O notation (also called &quot;asymptotic growth&quot; notation) is <em>what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin</em>. We use it to talk about <strong>how thing scale</strong>.</p>
<hr />
<p><strong>Basics</strong></p>
<p><strong>for &quot;sufficiently&quot; large inputs...</strong></p>
<ul>
<li><code>f(x) ∈ O(upperbound)</code> means <code>f</code> &quot;grows no faster than&quot; <code>upperbound</code></li>
<li><code>f(x) ∈ Ɵ(justlikethis)</code> mean <code>f</code> &quot;grows exactly like&quot; <code>justlikethis</code></li>
<li><code>f(x) ∈ Ω(lowerbound)</code> means <code>f</code> &quot;grows no slower than&quot; <code>lowerbound</code></li>
</ul>
<p>big-O notation doesn't care about constant factors: the function <code>9x²</code> is said to &quot;grow exactly like&quot; <code>10x²</code>. Neither does big-O <em>asymptotic</em> notation care about <em>non-asymptotic</em> stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function <code>10x²</code> is said to &quot;grow exactly like&quot; <code>10x² - x + 2</code>.</p>
<p>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</p>
<p>Put another way, it's all about the <strong>ratio</strong> as you go to infinity. <em>If you divide the actual time it takes by the <code>O(...)</code>, you will get a constant factor in the limit of large inputs.</em> Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</p>
<pre><code>actualAlgorithmTime(N) ∈ O(bound(N))
                                       e.g. &quot;time to mergesort N elements 
                                             is O(N log(N))&quot;
</code></pre>
<p>... this means that <em><strong>for &quot;large enough&quot; problem sizes N</strong></em> (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</p>
<pre><code>actualAlgorithmTime(N)                 e.g. &quot;mergesort_duration(N)       &quot;
────────────────────── &lt; constant            ───────────────────── &lt; 2.5 
       bound(N)                                    N log(N)         
</code></pre>
<p>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;<em>In the worst-case scenario, the time it takes will never be worse than roughly <code>N*log(N)</code>, within a factor of 2.5 (a constant factor we don't care much about)</em>&quot;.</p>
<p>In general, <code>O(...)</code> is the most useful one because we often care about worst-case behavior. If <code>f(x)</code> represents something &quot;bad&quot; like the processor or memory usage, then &quot;<code>f(x) ∈ O(upperbound)</code>&quot; means &quot;<code>upperbound</code> is the worst-case scenario of processor/memory usage&quot;.</p>
<hr />
<p><strong>Applications</strong></p>
<p>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</p>
<ul>
<li>the number of possible handshakes among <code>N</code> people at a party (<code>Ɵ(N²)</code>, specifically <code>N(N-1)/2</code>, but what matters is that it &quot;scales like&quot; <code>N²</code>)</li>
<li>probabilistic expected number of people who have seen some viral marketing as a function of time</li>
<li>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</li>
<li>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</li>
<li>how much time an algorithm needs to run, as a function of input size</li>
<li>how much space an algorithm needs to run, as a function of input size</li>
</ul>
<hr />
<p><strong>Example</strong></p>
<p>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, <code>#handshakes ∈ Ɵ(N²)</code>. Why?</p>
<p>Back up a bit: the number of handshakes is exactly n-choose-2 or <code>N*(N-1)/2</code> (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</p>
<p><a href="https://i.stack.imgur.com/L4HUw.png" rel="noreferrer"><img src="https://i.stack.imgur.com/L4HUw.png" alt="everyone handshakes everyone else. Image credit and license per Wikipedia/Wikimedia commons &quot;complete graph&quot; article." /></a> <a href="https://i.stack.imgur.com/rqQMF.png" rel="noreferrer"><img src="https://i.stack.imgur.com/rqQMF.png" alt="adjacency matrix" /></a></p>
<p>However, for very large numbers of people, the linear term <code>N</code> is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is <code>order N²</code>, or the number of handshakes &quot;grows like N²&quot;.</p>
<pre><code>#handshakes(N)
────────────── ≈ 1/2
     N²
</code></pre>
<p>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N<sup>2</sup> checkmarks asymptotically).</p>
<p>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (<code>lim</code> means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</p>
<pre><code>    N²/2 - N/2         (N²)/2   N/2         1/2
lim ────────── = lim ( ────── - ─── ) = lim ─── = 1/2
N→∞     N²       N→∞     N²     N²      N→∞  1
                               ┕━━━┙
             this is 0 in the limit of N→∞:
             graph it, or plug in a really large number for N
</code></pre>
<p><strong>tl;dr: The number of handshakes 'looks like' x² so much for large values, that if we were to write down the ratio #handshakes/x², the fact that we don't need <em>exactly</em> x² handshakes wouldn't even show up in the decimal for an arbitrarily large while.</strong></p>
<blockquote>
<p>e.g. for x=1million, ratio #handshakes/x²: 0.499999...</p>
</blockquote>
<hr />
<p><strong>Building Intuition</strong></p>
<p>This lets us make statements like...</p>
<blockquote>
<p>&quot;For large enough inputsize=N, no matter what the constant factor is, if I <em><strong>double</strong> the input size</em>...</p>
</blockquote>
<ul>
<li>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</li>
</ul>
<blockquote class="spoiler">
<p>       <strong>N</strong> → (2N) = 2(<strong>N</strong>)</p>
</blockquote>
<ul>
<li>... I double-squared (quadruple) the time an O(N²) (&quot;quadratic time&quot;) algorithm takes.&quot; <em>(e.g. a problem 100x as big takes 100²=10000x as long... possibly unsustainable)</em></li>
</ul>
<blockquote class="spoiler">
<p>   <strong>N²</strong> → (2N)² = 4(<strong>N²</strong>)</p>
</blockquote>
<ul>
<li>... I double-cubed (octuple) the time an O(N³) (&quot;cubic time&quot;) algorithm takes.&quot; <em>(e.g. a problem 100x as big takes 100³=1000000x as long... very unsustainable)</em></li>
</ul>
<blockquote class="spoiler">
<p>   <strong>cN³</strong> → c(2N)³ = 8(<strong>cN³</strong>)</p>
</blockquote>
<ul>
<li>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; <em>(cheap!)</em></li>
</ul>
<blockquote class="spoiler">
<p>  <strong>c log(N)</strong> → c log(2N) = (c log(2))+(<strong>c log(N)</strong>) = (fixed amount)+(<strong>c log(N)</strong>)</p>
</blockquote>
<ul>
<li>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; <em>(the cheapest!)</em></li>
</ul>
<blockquote class="spoiler">
<p>                <strong>c*1</strong> → <strong>c*1</strong></p>
</blockquote>
<ul>
<li>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; <em>(fairly common)</em></li>
</ul>
<blockquote class="spoiler">
<p>  <strong>c 2N log(2N) / c N log(N)</strong>  (here we divide f(2n)/f(n), but we could have as above massaged the expression and factored out cNlogN as above)
<br/>         → 2 log(2N)/log(N)
<br/>         → 2 (log(2) + log(N))/log(N)
<br/>         → 2*(1+(log<sub>2</sub>N)<sup>-1</sup>)  (basically 2 for large N; eventually less than 2.000001)
<br/>(alternatively, say log(N) will always be below like 17 for your data so it's O(17 N) which is linear; that is not rigorous nor sensical though)</p>
</blockquote>
<ul>
<li>... I ridiculously increase the time a O(2<sup>N</sup>) (&quot;exponential time&quot;) algorithm takes.&quot; <em>(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)</em></li>
</ul>
<blockquote class="spoiler">
<p>     <strong>2<sup>N</sup></strong> → 2<sup>2N</sup> = (4<sup>N</sup>)............put another way...... <strong>2<sup>N</sup></strong> → 2<sup>N+1</sup> = 2<sup>N</sup>2<sup>1</sup> = 2 <strong>2<sup>N</sup></strong></p>
</blockquote>
<p>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</p>
<p>(with credit to <a href="https://stackoverflow.com/a/487292/711085">https://stackoverflow.com/a/487292/711085</a> )</p>
<p>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</p>
<p>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(√N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</p>
<hr />
<p><strong>Constant factors</strong></p>
<p>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take <code>O(N)</code> time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( <a href="https://stackoverflow.com/questions/385506/when-is-optimisation-premature">When is optimisation premature?</a> ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</p>
<p>Some asymptotically superior algorithms (e.g. a non-comparison <code>O(N log(log(N)))</code> sort) can have so large a constant factor (e.g. <code>100000*N log(log(N))</code>), or overhead that is relatively large like <code>O(N log(log(N)))</code> with a hidden <code>+ 100*N</code>, that they are rarely worth using even on &quot;big data&quot;.</p>
<hr />
<p><strong>Why O(N) is sometimes the best you can do, i.e. why we need datastructures</strong></p>
<p><code>O(N)</code> algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The <strong>very act of reading</strong> a bunch of data is an <code>O(N)</code> operation. Loading it into memory is usually <code>O(N)</code> (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even <em>look</em> at every piece of data (or even every other piece of data), your algorithm will take <code>O(N)</code> time to perform this looking. No matter how long your actual algorithm takes, it will be at least <code>O(N)</code> because it spent that time looking at all the data.</p>
<p>The same can be said for the <strong>very act of writing</strong>. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: <code>O(N!)</code> (which is why in those cases, good programs will ensure an iteration uses O(1) memory and doesn't print or store every intermediate step)).</p>
<p>This motivates the use of <strong>data structures</strong>: a data structure requires reading the data only once (usually <code>O(N)</code> time), plus some arbitrary amount of preprocessing (e.g. <code>O(N)</code> or <code>O(N log(N))</code> or <code>O(N²)</code>) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as <code>O(1)</code> or <code>O(log(N))</code>. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</p>
<p>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</p>
<ul>
<li>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</li>
<li>If you only needed to do this once, it would not be a problem to have to do the naive method of <code>O(N)</code> work only once, but if you want to do it many times (in this case, <code>N</code> times, once for each segment), we'd have to do <code>O(N²)</code> work, or 1000000²=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</li>
<li>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in <code>O(N)</code> time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</li>
<li>Our task went from an infeasible <code>O(N²)</code> to a manageable <code>O(N)</code>, and all we had to do was pay a minor cost to make a hash table.</li>
<li><strong>analogy</strong>: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</li>
</ul>
<p>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</p>
<hr />
<p><strong>Practical example: visualizing orders of growth while coding</strong></p>
<p>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you <em>apply</em> asymptotic notation to coding.</p>
<p>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</p>
<p>(here, the <code>x</code>s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</p>
<pre><code>for(i=0; i&lt;A; i++)        // A * ...
    some O(1) operation     // 1

--&gt; A*1 --&gt; O(A) time

visualization:

|&lt;------ A -------&gt;|
1 2 3 4 5 x x ... x

other languages, multiplying orders of growth:
  javascript, O(A) time and space
    someListOfSizeA.map((x,i) =&gt; [x,i])               
  python, O(rows*cols) time and space
    [[r*c for c in range(cols)] for r in range(rows)]
</code></pre>
<p>Example 2:</p>
<pre><code>for every x in listOfSizeA:   // A * (...
    some O(1) operation         // 1
    some O(B) operation         // B
    for every y in listOfSizeC: // C * (...
        some O(1) operation       // 1))

--&gt; O(A*(1 + B + C))
    O(A*(B+C))        (1 is dwarfed)

visualization:

|&lt;------ A -------&gt;|
1 x x x x x x ... x

2 x x x x x x ... x ^
3 x x x x x x ... x |
4 x x x x x x ... x |
5 x x x x x x ... x B  &lt;-- A*B
x x x x x x x ... x |
................... |
x x x x x x x ... x v

x x x x x x x ... x ^
x x x x x x x ... x |
x x x x x x x ... x |
x x x x x x x ... x C  &lt;-- A*C
x x x x x x x ... x |
................... |
x x x x x x x ... x v
</code></pre>
<p>Example 3:</p>
<pre><code>function nSquaredFunction(n) {
    total = 0
    for i in 1..n:        // N *
        for j in 1..n:      // N *
            total += i*k      // 1
    return total
}
// O(n^2)

function nCubedFunction(a) {
    for i in 1..n:                // A *
        print(nSquaredFunction(a))  // A^2
}
// O(a^3)
</code></pre>
<p>If we do something slightly complicated, you might still be able to imagine visually what's going on:</p>
<pre><code>for x in range(A):
    for y in range(1..x):
        simpleOperation(x*y)

x x x x x x x x x x |
x x x x x x x x x   |
x x x x x x x x     |
x x x x x x x       |
x x x x x x         |
x x x x x           |
x x x x             |
x x x               |
x x                 |
x___________________|
</code></pre>
<p>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</p>
<p>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</p>
<p>Here is another thing we can recognize visually:</p>
<pre><code>&lt;----------------------------- N -----------------------------&gt;
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x
x x x x x x x x x x x x x x x x
x x x x x x x x
x x x x
x x
x
</code></pre>
<p>We can just rearrange this and see it's O(N):</p>
<pre><code>&lt;----------------------------- N -----------------------------&gt;
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x
x x x x x x x x x x x x x x x x|x x x x x x x x|x x x x|x x|x
</code></pre>
<p>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</p>
<pre><code>   &lt;----------------------------- N -----------------------------&gt;
 ^  x x x x x x x x x x x x x x x x|x x x x x x x x x x x x x x x x
 |  x x x x x x x x|x x x x x x x x|x x x x x x x x|x x x x x x x x
lgN x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x|x x x x
 |  x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x|x x
 v  x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x
</code></pre>
<p>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</p>
<pre><code>[myDictionary.has(x) for x in listOfSizeA]
 \----- O(1) ------/    

--&gt; A*1 --&gt; O(A)
</code></pre>
<p>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, <strike>you can use the <a href="https://en.wikipedia.org/wiki/Master_theorem" rel="noreferrer">Master Theorem</a> (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)</strike> you look up the running time of your algorithm on Wikipedia.</p>
<p>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something <strong>grossly inefficient?</strong>&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</p>
<hr />
<p><strong>Amortized and average-case complexity</strong></p>
<p>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</p>
<p><strong>Average Case</strong>: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is <code>O(N^2)</code> for some really bad inputs, the average case is the usual <code>O(N log(N))</code> (the really bad inputs are very small in number, so few that we don't notice them in the average case).</p>
<p><strong>Amortized Worst-Case</strong>: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant <code>O(1)</code> time. However, occasionally it will 'hiccup' and take <code>O(N)</code> time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still <code>O(N)</code> per operation, but the amortized cost <em>over many runs</em> is <code>O(N)/N</code> = <code>O(1)</code> per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</p>
<blockquote>
<p>The analogy for amortized analysis:</p>
<p>You drive a car. Occasionally, you need to spend 10 minutes going to
the gas station and then spend 1 minute refilling the tank with gas.
If you did this every time you went anywhere with your car (spend 10
minutes driving to the gas station, spend a few seconds filling up a
fraction of a gallon), it would be very inefficient. But if you fill
up the tank once every few days, the 11 minutes spent driving to the
gas station is &quot;amortized&quot; over a sufficiently large number of trips,
that you can ignore it and pretend all your trips were maybe 5% longer.</p>
</blockquote>
<p>Comparison between average-case and amortized worst-case:</p>
<ul>
<li>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</li>
<li>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</li>
</ul>
<p>Though, if you're <a href="https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks" rel="noreferrer">reasonably worried</a> about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</p>
<p>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</p>
<p>(See <a href="https://stackoverflow.com/q/7333376/711085">Difference between average case and amortized analysis</a> if interested in this subtopic.)</p>
<hr />
<p><strong>Multidimensional big-O</strong></p>
<p>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time <code>O([length of text] + [length of query])</code>, i.e. it is linear in two variables like <code>O(N+M)</code>. Other more naive algorithms may be <code>O([length of text]*[length of query])</code> or <code>O(N*M)</code>. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</p>
<hr />
<p><strong>The whole story</strong></p>
<p>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often <em>independent</em> of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</p>
<p>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</p>
<ul>
<li>If you're sorting something like 5 elements, you don't want to use the speedy <code>O(N log(N))</code> quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</li>
<li>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</li>
</ul>
<p>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both <code>O(N log(N))</code>, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</p>
<p>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</p>
<p>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because <em>sometimes</em> (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (<code>O(log(N))</code> rather than <code>O(1)</code> for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</p>
<hr />
<p>(<em>edit</em>: The &quot;plain English&quot; explanation ends here.)</p>
<p><em>Math addenda</em></p>
<p><i>For completeness, the precise definition of big-O notation is as follows: <code>f(x) ∈ O(g(x))</code> means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that <code>|f(x)| ≤ const * |g(x)|</code>. (The other symbols are as follows: just like <code>O</code> means ≤, <code>Ω</code> means ≥. There are lowercase variants: <code>o</code> means &lt;, and <code>ω</code> means &gt;.) <code>f(x) ∈ Ɵ(g(x))</code> means both <code>f(x) ∈ O(g(x))</code> and <code>f(x) ∈ Ω(g(x))</code> (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between <code>const1*g(x)</code> and <code>const2*g(x)</code>. It is the strongest asymptotic statement you can make and roughly equivalent to <code>==</code>. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</p>
<p>People will often use <code>= O(...)</code>, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous <code>∈ O(...)</code>. <code>∈</code> means &quot;is an element of&quot; (still read as before). In this particular case, <code>O(N²)</code> contains elements like {<code>2 N²</code>, <code>3 N²</code>, <code>1/2 N²</code>, <code>2 N² + log(N)</code>, <code>- N² + N^1.9</code>, ...} and is infinitely large, but it's still a set.</p>
<p>O and Ω are not symmetric (n = O(n²), but n² is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into <em>equivalence classes</em>. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I <em>think</em>); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</p>
<p>The <code>=</code> notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say <code>O(...)</code> when they mean <code>Ɵ(...)</code>; this is technically true since the set of things <code>Ɵ(exactlyThis)</code> is a subset of <code>O(noGreaterThanThis)</code>... and it's easier to type. ;-)</i></p>
</div><p class="this-has-helped">This answer has helped 255 people.</p><div class="s-prose js-post-body"><p>EDIT: Quick note, this is almost certainly confusing <a href="http://en.wikipedia.org/wiki/Big_O_notation" rel="noreferrer">Big O notation</a> (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</p>

<p>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</p>

<p>Obviously that's only using "size" as the input and "time taken" as the output &mdash; the same idea applies if you want to talk about memory usage etc.</p>

<p>Here's an example where we have N T-shirts which we want to dry. We'll <em>assume</em> it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</p>

<ul>
<li><p>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</p></li>
<li><p>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &mdash; they're irrelevant.) So drying 50 shirts takes <em>about</em> 5 times as long as drying 10 shirts.</p></li>
<li><p>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &mdash; as you increase the wash load, the drying time increases faster.</p></li>
</ul>

<p>One important aspect of "big O" notation is that it <em>doesn't</em> say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, "find the first element where the string part matches the given key.") Hashtables are generally amortised (~= "on average") O(1) &mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &mdash; on average, you're going to have to look at half the entries.</p>

<p>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</p>
</div><p class="this-has-helped">This answer has helped 137 people.</p><div class="s-prose js-post-body"><p>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</p>

<p>Examples:</p>

<ul>
<li><p>O(n): If I double the input size the runtime doubles</p></li>
<li><p>O(n<sup>2</sup>): If the input size doubles the runtime quadruples</p></li>
<li><p>O(log n): If the input size doubles the runtime increases by one</p></li>
<li><p>O(2<sup>n</sup>): If the input size increases by one, the runtime doubles</p></li>
</ul>

<p>The input size is usually the space in bits needed to represent the input.</p>
</div></body></html>