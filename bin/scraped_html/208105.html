<!DOCTYPE html><html lang="en"><head><style>@import url("https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;1,200;1,300&family=Work+Sans:wght@400;500&display=swap");</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><head><link href="../../src/css/general.css" rel="stylesheet" /></head><p class='question-hyperlink'>How do I remove a property from a JavaScript object?</p><div class="s-prose js-post-body"><p>Given an object:</p>
<pre><code>let myObject = {
  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,
  &quot;method&quot;: &quot;newURI&quot;,
  &quot;regex&quot;: &quot;^http://.*&quot;
};
</code></pre>
<p>How do I remove the property <code>regex</code> to end up with the following <code>myObject</code>?</p>
<pre><code>let myObject = {
  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,
  &quot;method&quot;: &quot;newURI&quot;
};
</code></pre>
</div><p class="this-has-helped">This answer has helped 9634 people.</p><div class="s-prose js-post-body"><p>To remove a property from an object (mutating the object), you can do it like this:</p>
<pre><code>delete myObject.regex;
// or,
delete myObject['regex'];
// or,
var prop = &quot;regex&quot;;
delete myObject[prop];
</code></pre>
<p>Demo
<div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var myObject = {
    "ircEvent": "PRIVMSG",
    "method": "newURI",
    "regex": "^http://.*"
};
delete myObject.regex;

console.log(myObject);</code></pre>
</div>
</div>
</p>
<p>For anyone interested in reading more about it, Stack Overflow user <a href="https://stackoverflow.com/users/130652/kangax">kangax</a> has written an incredibly in-depth blog post about the <code>delete</code> statement on their blog, <em><a href="http://perfectionkills.com/understanding-delete" rel="noreferrer">Understanding delete</a></em>. It is highly recommended.</p>
<p>If you'd like a <em>new</em> object with all the keys of the original except some, you could use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring" rel="noreferrer">destructuring</a>.</p>
<p>Demo
<div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*"
};

// assign the key regex to the variable _ indicating it will be unused
const {regex: _, ...newObj} = myObject;

console.log(newObj);   // has no 'regex' key
console.log(myObject); // remains unchanged</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 1098 people.</p><div class="s-prose js-post-body"><p>Objects in JavaScript can be thought of as maps between keys and values. The <code>delete</code> operator is used to remove these keys, more commonly known as object properties, one at a time.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var obj = {
  myProperty: 1    
}
console.log(obj.hasOwnProperty('myProperty')) // true
delete obj.myProperty
console.log(obj.hasOwnProperty('myProperty')) // false</code></pre>
</div>
</div>
</p>

<p>The <code>delete</code> operator does not directly free memory, and it differs from simply assigning the value of <code>null</code> or <code>undefined</code> to a property, in that the property <em>itself</em> is removed from the object. Note that if the <em>value</em> of a deleted property was a reference type (an object), and another part of your program still holds a reference to that object, then that object will, of course, not be garbage collected until all references to it have disappeared.</p>

<p><code>delete</code> will only work on properties whose descriptor marks them as configurable.</p>
</div><p class="this-has-helped">This answer has helped 371 people.</p><div class="s-prose js-post-body"><p>Old question, modern answer. Using object destructuring, an <a href="https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015">ECMAScript&nbsp;6</a> feature, it's as simple as:</p>

<pre><code>const { a, ...rest } = { a: 1, b: 2, c: 3 };
</code></pre>

<p>Or with the questions sample:</p>

<pre><code>const myObject = {"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};
const { regex, ...newObject } = myObject;
console.log(newObject);
</code></pre>

<p><a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=es2015%2Cstage-0&amp;experimental=true&amp;loose=true&amp;spec=false&amp;code=const%20myObject%20%3D%20%7B%22ircEvent%22%3A%20%22PRIVMSG%22%2C%20%22method%22%3A%20%22newURI%22%2C%20%22regex%22%3A%20%22%5Ehttp%3A%2F%2F.*%22%7D%3B%0Aconst%20%7B%20regex%2C%20...newObject%20%7D%20%3D%20myObject%3B%0Aconsole.log(newObject)%3B">You can see it in action in the Babel try-out editor.</a></p>

<hr>

<p><strong>Edit:</strong></p>

<p>To reassign to the same variable, use a <code>let</code>:</p>

<pre><code>let myObject = {"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};
({ regex, ...myObject } = myObject);
console.log(myObject);
</code></pre>
</div><p class="this-has-helped">This answer has helped 309 people.</p><div class="s-prose js-post-body"><p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var myObject = {"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};
    
delete myObject.regex;

console.log ( myObject.regex); // logs: undefined</code></pre>
</div>
</div>
</p>

<p>This works in Firefox and Internet&nbsp;Explorer, and I think it works in all others.</p>
</div><p class="this-has-helped">This answer has helped 290 people.</p><div class="s-prose js-post-body"><p>The <code>delete</code> operator is used to remove properties from objects.</p>
<pre><code>const obj = { foo: &quot;bar&quot; };

delete obj.foo;
obj.hasOwnProperty(&quot;foo&quot;); // false
</code></pre>
<p>Note that, for arrays, <strong>this is not the same as removing an element</strong>. To remove an element from an array, use <code>Array#splice</code> or <code>Array#pop</code>. For example:</p>
<pre><code>arr;             // [0, 1, 2, 3, 4]
arr.splice(3,1); // 3
arr;             // [0, 1, 2, 4]
</code></pre>
<h1>Details</h1>
<p>Strictly speaking, it's impossible to truly delete anything in JavaScript. The <code>delete</code> operator neither deletes objects nor frees memory. Rather, it sets its operand to <code>undefined</code> and manipulates the parent object so that the member is gone.</p>
<pre><code>let parent = {
    member: { str: &quot;Hello&quot; }
};
let secondref = parent.member;

delete parent.member;
parent.member;        // undefined
secondref;            // { str: &quot;Hello&quot; }
</code></pre>
<p>The <em>object</em> is not deleted. Only the reference is. Memory is only freed
by the garbage collector when all references to an object are removed.</p>
<p>Another important caveat is that the <code>delete</code> operator will not reorganize structures for you, which has results that can seem counterintuitive. Deleting an array index, for example, will leave a &quot;hole&quot; in it.</p>
<pre><code>let array = [0, 1, 2, 3]; // [0, 1, 2, 3]
delete array[2];          // [0, 1, empty, 3]
</code></pre>
<p>This is because arrays <em>are</em> objects. So indices are the same as keys.</p>
<pre><code>let fauxarray = {0: 1, 1: 2, length: 2};
fauxarray.__proto__ = [].__proto__;
fauxarray.push(3);
fauxarray;                // [1, 2, 3]
Array.isArray(fauxarray); // false
Array.isArray([1, 2, 3]); // true
</code></pre>
<p>Different built-in functions in JavaScript handle arrays with holes in them differently.</p>
<ul>
<li><p><code>for..in</code> statements will skip the empty index completely.</p>
</li>
<li><p>A naive <code>for</code> loop will yield <code>undefined</code> for the value at the index.</p>
</li>
<li><p>Any method using <code>Symbol.iterator</code> will return <code>undefined</code> for the value at the index.</p>
</li>
<li><p><code>forEach</code>, <code>map</code> and <code>reduce</code> will simply skip the missing index, <strong>but will not remove it</strong></p>
</li>
</ul>
<p>Example:</p>
<pre><code>let array = [1, 2, 3]; // [1,2,3]
delete array[1];       // [1, empty, 3]
array.map(x =&gt; 0);     // [0, empty, 0]
</code></pre>
<p>So, the <code>delete</code> operator should not be used for the common use-case of removing elements from an array. Arrays have a dedicated methods for removing elements and reallocating memory: <code>Array#splice()</code> and <code>Array#pop</code>.</p>
<h2>Array#splice(start[, deleteCount[, item1[, item2[, ...]]]])</h2>
<p><code>Array#splice</code> mutates the array, and returns any removed indices. <code>deleteCount</code> elements are removed from index <code>start</code>, and <code>item1, item2... itemN</code> are inserted into the array from index <code>start</code>. If <code>deleteCount</code> is omitted then elements from startIndex are removed to the end of the array.</p>
<pre><code>let a = [0,1,2,3,4]
a.splice(2,2) // returns the removed elements [2,3]
// ...and `a` is now [0,1,4]
</code></pre>
<p>There is also a similarly named, but different, function on <code>Array.prototype</code>: <code>Array#slice</code>.</p>
<h2>Array#slice([begin[, end]])</h2>
<p><code>Array#slice</code> is non-destructive, and returns a new array containing the indicated indices from <code>start</code> to <code>end</code>. If <code>end</code> is left unspecified, it defaults to the end of the array. If <code>end</code> is positive, it specifies the zero-based <strong>non-inclusive</strong> index to stop at. If <code>end</code> is negative it, it specifies the index to stop at by counting back from the end of the array (eg. -1 will omit the final index). If <code>end &lt;= start</code>, the result is an empty array.</p>
<pre><code>let a = [0,1,2,3,4]
let slices = [
    a.slice(0,2),
    a.slice(2,2),
    a.slice(2,3),
    a.slice(2,5) ]

//   a           [0,1,2,3,4]
//   slices[0]   [0 1]- - -   
//   slices[1]    - - - - -
//   slices[2]    - -[3]- -
//   slices[3]    - -[2 4 5]
</code></pre>
<h1>Array#pop</h1>
<p><code>Array#pop</code> removes the last element from an array, and returns that element. This operation changes the length of the array. The opposite operation is <code>push</code></p>
<h1>Array#shift</h1>
<p><code>Array#shift</code> is similar to <code>pop</code>, except it removes the first element. The opposite operation is <code>unshift</code>.</p>
</div><p class="this-has-helped">This answer has helped 255 people.</p><div class="s-prose js-post-body"><h1><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">Spread Syntax</a> (ES6)</h1>
<p>To complete <a href="https://stackoverflow.com/questions/208105/how-do-i-remove-a-property-from-a-javascript-object/40493600#40493600">Koen's answer</a>, in case you want to remove a dynamic variable using the spread syntax, you can do it like so:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const key = 'a';

const { [key]: foo, ...rest } = { a: 1, b: 2, c: 3 };

console.log(foo);  // 1
console.log(rest); // { b: 2, c: 3 }</code></pre>
</div>
</div>
</p>
<p>* <em><code>foo</code> will be a new variable with the value of <code>a</code> (which is 1).</em></p>
<h3>Extended answer 😇</h3>
<p>There are a few common ways to remove a property from an object. <br/>Each one has its own pros and cons (<a href="https://jsperf.com/delete-vs-undefined-vs-null/16" rel="noreferrer">check this performance comparison</a>):</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" rel="noreferrer"><em><strong>Delete Operator</strong></em></a></p>
<p>It is readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</p>
<pre><code>delete obj[key];
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" rel="noreferrer"><em><strong>Reassignment</strong></em></a></p>
<p>It is more than two times faster than <code>delete</code>, however the property is <strong>not</strong> deleted and can be iterated.</p>
<pre><code>obj[key] = null;
obj[key] = false;
obj[key] = undefined;
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer"><em><strong>Spread Operator</strong></em></a></p>
<p>This <code>ES6</code> operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and is not suggested to be used when you need to remove many properties at a time.</p>
<pre><code>{ [key]: val, ...rest } = obj;
</code></pre>
</div><p class="this-has-helped">This answer has helped 123 people.</p><div class="s-prose js-post-body"><p>Another alternative is to use the <a href="https://underscorejs.org" rel="noreferrer">Underscore.js</a> library. </p>

<p>Note that <code>_.pick()</code> and <code>_.omit()</code> both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</p>

<p>Reference: <a href="http://underscorejs.org/#pick" rel="noreferrer">link</a> <strong>_.pick(object, *keys)</strong></p>

<p>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</p>

<pre><code>var myJSONObject = 
{"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};

_.pick(myJSONObject, "ircEvent", "method");
=&gt; {"ircEvent": "PRIVMSG", "method": "newURI"};
</code></pre>

<p>Reference: <a href="http://underscorejs.org/#omit" rel="noreferrer">link</a> <strong>_.omit(object, *keys)</strong></p>

<p>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</p>

<pre><code>var myJSONObject = 
{"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};

_.omit(myJSONObject, "regex");
=&gt; {"ircEvent": "PRIVMSG", "method": "newURI"};
</code></pre>

<p>For arrays, <code>_.filter()</code> and <code>_.reject()</code> can be used in a similar manner. </p>
</div><p class="this-has-helped">This answer has helped 120 people.</p><div class="s-prose js-post-body"><p><strong>To clone an object without a property:</strong></p>
<p>For example:</p>
<pre><code>let object = { a: 1, b: 2, c: 3 };
</code></pre>
<p>And we need to delete <code>a</code>.</p>
<ol>
<li><p>With an <strong>explicit prop key</strong>:</p>
<pre><code>const { a, ...rest } = object;
object = rest;
</code></pre>
</li>
<li><p>With a <strong>variable prop key</strong>:</p>
<pre><code>const propKey = 'a';
const { [propKey]: propValue, ...rest } = object;
object = rest;
</code></pre>
</li>
<li><p>A cool <strong>arrow function</strong> 😎:</p>
<pre><code>const removeProperty = (propKey, { [propKey]: propValue, ...rest }) =&gt; rest;

object = removeProperty('a', object);
</code></pre>
</li>
<li><p>For <strong>multiple properties</strong></p>
<pre><code>const removeProperties = (object, ...keys) =&gt; (keys.length ? removeProperties(removeProperty(keys.pop(), object), ...keys) : object);
</code></pre>
</li>
</ol>
<p><em><strong>Usage</strong></em></p>
<pre><code>object = removeProperties(object, 'a', 'b') // result =&gt; { c: 3 }
</code></pre>
<p><em><strong>Or</strong></em></p>
<pre><code>const propsToRemove = ['a', 'b']
object = removeProperties(object, ...propsToRemove) // result =&gt; { c: 3 }
</code></pre>
</div><p class="this-has-helped">This answer has helped 78 people.</p><div class="s-prose js-post-body"><p>The term you have used in your question title, <em>Remove a property from a JavaScript object</em>, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the <code>delete</code> keyword is the main part. Let's say you have your object like:</p>
<pre><code>myJSONObject = {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;};
</code></pre>
<p>If you do:</p>
<pre><code>console.log(Object.keys(myJSONObject));
</code></pre>
<p>the result would be:</p>
<pre><code>[&quot;ircEvent&quot;, &quot;method&quot;, &quot;regex&quot;]
</code></pre>
<p>You can delete that specific key from your object keys like:</p>
<pre><code>delete myJSONObject[&quot;regex&quot;];
</code></pre>
<p>Then your objects key using <code>Object.keys(myJSONObject)</code> would be:</p>
<pre><code>[&quot;ircEvent&quot;, &quot;method&quot;]
</code></pre>
<p>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</p>
<pre><code>myJSONObject[&quot;regex&quot;] = null;
delete myJSONObject[&quot;regex&quot;];
</code></pre>
<p>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</p>
<pre><code>var regex = myJSONObject[&quot;regex&quot;];
</code></pre>
<p>Or add it as a new pointer to another object like:</p>
<pre><code>var myOtherObject = {};
myOtherObject[&quot;regex&quot;] = myJSONObject[&quot;regex&quot;];
</code></pre>
<p>Then even if you remove it from your object <code>myJSONObject</code>, that specific object won't get deleted from the memory, since the <code>regex</code> variable and <code>myOtherObject[&quot;regex&quot;]</code> still have their values. Then how could we remove the object from the memory for sure?</p>
<p>The answer would be to <strong>delete all the references you have in your code, pointed to that very object</strong> and also <strong>not use <code>var</code> statements to create new references to that object</strong>. This last point regarding <code>var</code> statements, is one of the most crucial issues that we are usually faced with, because using <code>var</code> statements would prevent the created object from getting removed.</p>
<p>Which means in this case you won't be able to remove that object because you have created the <code>regex</code> variable via a <code>var</code> statement, and if you do:</p>
<pre><code>delete regex; //False
</code></pre>
<p>The result would be <code>false</code>, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had <code>myOtherObject[&quot;regex&quot;]</code> as your last existing reference, you could have done this just by removing it like:</p>
<pre><code>myOtherObject[&quot;regex&quot;] = null;
delete myOtherObject[&quot;regex&quot;];
</code></pre>
<p><strong>In other words, a JavaScript object is eligible to be killed as soon as there is no reference left in your code pointed to that object.</strong></p>
<hr />
<p><strong>Update:</strong></p>
<p>Thanks to @AgentME:</p>
<blockquote>
<p>Setting a property to null before deleting it doesn't accomplish
anything (unless the object has been sealed by Object.seal and the
delete fails. That's not usually the case unless you specifically
try).</p>
</blockquote>
<p>To get more information on <code>Object.seal</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" rel="nofollow noreferrer">Object.seal()</a></p>
</div><p class="this-has-helped">This answer has helped 55 people.</p><div class="s-prose js-post-body"><p>ECMAScript 2015 (or ES6) came with built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a> object. It is possible to delete object property by calling <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty">Reflect.deleteProperty()</a> function with target object and property key as parameters:</p>

<pre><code>Reflect.deleteProperty(myJSONObject, 'regex');
</code></pre>

<p>which is equivalent to:</p>

<pre><code>delete myJSONObject['regex'];
</code></pre>

<p>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</p>

<pre><code>let obj = Object.freeze({ prop: "value" });
let success = Reflect.deleteProperty(obj, "prop");
console.log(success); // false
console.log(obj.prop); // value
</code></pre>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze()</a> makes all properties of object not configurable (besides other things). <code>deleteProperty</code> function (as well as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete">delete operator</a>) returns <code>false</code> when tries to delete any of it's properties. If property is configurable it returns <code>true</code>, even if property does not exist.</p>

<p>The difference between <code>delete</code> and <code>deleteProperty</code> is when using strict mode:</p>

<pre><code>"use strict";

let obj = Object.freeze({ prop: "value" });
Reflect.deleteProperty(obj, "prop"); // false
delete obj["prop"];
// TypeError: property "prop" is non-configurable and can't be deleted
</code></pre>
</div><p class="this-has-helped">This answer has helped 52 people.</p><div class="s-prose js-post-body"><p>Suppose you have an object that looks like this:</p>

<pre><code>var Hogwarts = {
    staff : [
        'Argus Filch',
        'Filius Flitwick',
        'Gilderoy Lockhart',
        'Minerva McGonagall',
        'Poppy Pomfrey',
        ...
    ],
    students : [
        'Hannah Abbott',
        'Katie Bell',
        'Susan Bones',
        'Terry Boot',
        'Lavender Brown',
        ...
    ]
};
</code></pre>

<h3>Deleting an object property</h3>

<p>If you want to use the entire <code>staff</code> array, the proper way to do this, would be to do this:</p>

<pre><code>delete Hogwarts.staff;
</code></pre>

<p>Alternatively, you could also do this:</p>

<pre><code>delete Hogwarts['staff'];
</code></pre>

<p>Similarly, removing the entire students array would be done by calling <code>delete Hogwarts.students;</code> or <code>delete Hogwarts['students'];</code>.</p>

<h3>Deleting an array index</h3>

<p>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</p>

<p>If you know the index of your staff member, you could simply do this:</p>

<pre><code>Hogwarts.staff.splice(3, 1);
</code></pre>

<p>If you do not know the index, you'll also have to do an index search:</p>

<pre><code>Hogwarts.staff.splice(Hogwarts.staff.indexOf('Minerva McGonnagall') - 1, 1);
</code></pre>

<hr>

<h3>Note</h3>

<p>While you technically can use <code>delete</code> for an array, using it would result in getting incorrect results when calling for example <code>Hogwarts.staff.length</code> later on. In other words, <code>delete</code> would remove the element, but it wouldn't update the value of <code>length</code> property. Using <code>delete</code> would also mess up your indexing.</p>

<p>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</p>

<p>If you want to experiment with this, you can use <a href="http://jsfiddle.net/cb57dusv/46/"><strong>this Fiddle</strong></a> as a starting point.</p>
</div><p class="this-has-helped">This answer has helped 40 people.</p><div class="s-prose js-post-body"><p>I personally use <a href="https://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a> or <a href="https://lodash.com" rel="noreferrer">Lodash</a> for object and array manipulation:</p>

<pre><code>myObject = _.omit(myObject, 'regex');
</code></pre>
</div><p class="this-has-helped">This answer has helped 38 people.</p><div class="s-prose js-post-body"><p>Using <strong>delete</strong> method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</p>
<pre><code>delete myObject.regex;
// OR
delete myObject['regex'];
</code></pre>
<blockquote>
<p>The delete operator removes a given property from an object. On
successful deletion, it will return true, else false will be returned.
However, it is important to consider the following scenarios:</p>
</blockquote>
<blockquote>
<ul>
<li>If the property which you are trying to delete does not exist, delete
will not have any effect and will return true</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If a property with the same name exists on the object's prototype
chain, then, after deletion, the object will use the property from the
prototype chain (in other words, delete only has an effect on own
properties).</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Any property declared with var cannot be deleted from the global scope
or from a function's scope.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>As such, delete cannot delete any functions in the global scope (whether this is part of a function definition or a function  (expression).</li>
<li>Functions which are part of an object (apart from the<br />
global scope) can be deleted with delete.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Any property declared with let or const cannot be deleted from the scope within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</li>
</ul>
</blockquote>
<p>The following snippet gives another simple example:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var Employee = {
  age: 28,
  name: 'Alireza',
  designation: 'developer'
}

console.log(delete Employee.name);   // returns true
console.log(delete Employee.age);    // returns true

// When trying to delete a property that does 
// not exist, true is returned 
console.log(delete Employee.salary); // returns true</code></pre>
</div>
</div>
</p>
<p>For more info about and seeing more examples visit the link below:</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete</a></p>
</div><p class="this-has-helped">This answer has helped 34 people.</p><div class="s-prose js-post-body"><p>Another solution, using <strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noreferrer"><code>Array#reduce</code></a></strong>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*"
};

myObject = Object.keys(myObject).reduce(function(obj, key) {
  if (key != "regex") {           //key you want to remove
    obj[key] = myObject[key];
  }
  return obj;
}, {});

console.log(myObject);</code></pre>
</div>
</div>
</p>

<p>However, it will <strong>mutate</strong> the original object. If you want to create a new object <strong>without</strong> the specified key, just assign the reduce function to a new variable, e.g.: </p>

<p>(ES6)</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const myObject = {
  ircEvent: 'PRIVMSG',
  method: 'newURI',
  regex: '^http://.*',
};

const myNewObject = Object.keys(myObject).reduce((obj, key) =&gt; {
  key !== 'regex' ? obj[key] = myObject[key] : null;
  return obj;
}, {});

console.log(myNewObject);</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 28 people.</p><div class="s-prose js-post-body"><p>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</p>

<p>E.g</p>

<pre><code>var obj = {"property":"value", "property2":"value"};

if (obj &amp;&amp; obj.hasOwnProperty("property2")) {
  delete obj.property2;
} else {
  //error handling
}
</code></pre>

<p>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;&amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</p>

<p>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</p>
</div><p class="this-has-helped">This answer has helped 26 people.</p><div class="s-prose js-post-body"><p>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</p>
<p>The reason for writing this new <code>unset</code> function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function unset(unsetKey, unsetArr, resort) {
  var tempArr = unsetArr;
  var unsetArr = {};
  delete tempArr[unsetKey];
  if (resort) {
    j = -1;
  }
  for (i in tempArr) {
    if (typeof(tempArr[i]) !== 'undefined') {
      if (resort) {
        j++;
      } else {
        j = i;
      }
      unsetArr[j] = tempArr[i];
    }
  }
  return unsetArr;
}

var unsetArr = ['test', 'deletedString', 'test2'];

console.log(unset('1', unsetArr, true)); // output Object {0: "test", 1: "test2"}
console.log(unset('1', unsetArr, false)); // output Object {0: "test", 2: "test2"}</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 22 people.</p><div class="s-prose js-post-body"><p>There are a couple of ways to remove properties from an object:</p>
<p><strong>1) Remove using a dot property accessor (mutable)</strong></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*",
};

delete myObject.regex;
console.log(myObject);</code></pre>
</div>
</div>
</p>
<p><strong>2. Remove using square brackets property accessor (mutable)</strong></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const myObject = {
      "ircEvent": "PRIVMSG",
      "method": "newURI",
      "regex": "^http://.*",
    };

delete myObject['regex'];
console.log(myObject);
// or
const name = 'ircEvent';
delete myObject[name];
console.log(myObject);</code></pre>
</div>
</div>
</p>
<p><strong>3) Alternative option but without altering the original object, is using object destructuring and rest syntax (immutable)</strong></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code> const myObject = {
      "ircEvent": "PRIVMSG",
      "method": "newURI",
      "regex": "^http://.*",
    };

const { regex, ...myObjectRest} = myObject;
console.log(myObjectRest); </code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 20 people.</p><div class="s-prose js-post-body"><p>Using <a href="http://ramdajs.com/docs/#dissoc" rel="noreferrer">ramda#dissoc</a> you will get a new object without the attribute <code>regex</code>:</p>

<pre><code>const newObject = R.dissoc('regex', myObject);
// newObject !== myObject
</code></pre>

<p>You can also use other functions to achieve the same effect - omit, pick, ...</p>
</div><p class="this-has-helped">This answer has helped 19 people.</p><div class="s-prose js-post-body"><p>Try the following method. Assign the <code>Object</code> property value to <code>undefined</code>. Then <code>stringify</code> the object and <code>parse</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code> var myObject = {"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"};

myObject.regex = undefined;
myObject = JSON.parse(JSON.stringify(myObject));

console.log(myObject);</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 16 people.</p><div class="s-prose js-post-body"><h3 id="using-lodash-2jrs">Using <a href="https://en.wikipedia.org/wiki/Lodash" rel="noreferrer">Lodash</a></h3>
<pre><code>import omit from 'lodash/omit';

const prevObject = {test: false, test2: true};
// Removes test2 key from previous object
const nextObject = omit(prevObject, 'test2');
</code></pre>
<h3 id="using-ramda-845r">Using Ramda</h3>
<pre><code>R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}
</code></pre>
</div><p class="this-has-helped">This answer has helped 14 people.</p><div class="s-prose js-post-body"><p>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</p>

<pre><code>var deepObjectRemove = function(obj, path_to_key){
    if(path_to_key.length === 1){
        delete obj[path_to_key[0]];
        return true;
    }else{
        if(obj[path_to_key[0]])
            return deepObjectRemove(obj[path_to_key[0]], path_to_key.slice(1));
        else
            return false;
    }
};
</code></pre>

<p>Example: </p>

<pre><code>var a = {
    level1:{
        level2:{
            level3: {
                level4: "yolo"
            }
        }
    }
};

deepObjectRemove(a, ["level1", "level2", "level3"]);
console.log(a);

//Prints {level1: {level2: {}}}
</code></pre>
</div><p class="this-has-helped">This answer has helped 13 people.</p><div class="s-prose js-post-body"><p><a href="https://stackoverflow.com/questions/208105/how-do-i-remove-a-property-from-a-javascript-object/21735614#21735614">Dan's assertion</a> that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</p>
<pre><code>var iterationsTotal = 10000000;  // 10 million
var o;
var t1 = Date.now(),t2;
for (let i=0; i&lt;iterationsTotal; i++) {
   o = {a:1,b:2,c:3,d:4,e:5};
   delete o.a; delete o.b; delete o.c; delete o.d; delete o.e;
}
console.log ((t2=Date.now())-t1);  // 6135
for (let i=0; i&lt;iterationsTotal; i++) {
   o = {a:1,b:2,c:3,d:4,e:5};
   o.a = o.b = o.c = o.d = o.e = undefined;
}
console.log (Date.now()-t2);  // 205
</code></pre>
<p>Note that I purposely carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</p>
</div><p class="this-has-helped">This answer has helped 13 people.</p><div class="s-prose js-post-body"><h1>Object.assign() &amp; Object.keys() &amp; Array.map()</h1>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="true">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const obj = {
    "Filters":[
        {
            "FilterType":"between",
            "Field":"BasicInformationRow.A0",
            "MaxValue":"2017-10-01",
            "MinValue":"2017-09-01",
            "Value":"Filters value"
        }
    ]
};

let new_obj1 = Object.assign({}, obj.Filters[0]);
let new_obj2 = Object.assign({}, obj.Filters[0]);

/*

// old version

let shaped_obj1 = Object.keys(new_obj1).map(
    (key, index) =&gt; {
        switch (key) {
            case "MaxValue":
                delete new_obj1["MaxValue"];
                break;
            case "MinValue":
                delete new_obj1["MinValue"];
                break;
        }
        return new_obj1;
    }
)[0];


let shaped_obj2 = Object.keys(new_obj2).map(
    (key, index) =&gt; {
        if(key === "Value"){
            delete new_obj2["Value"];
        }
        return new_obj2;
    }
)[0];


*/


// new version!

let shaped_obj1 = Object.keys(new_obj1).forEach(
    (key, index) =&gt; {
        switch (key) {
            case "MaxValue":
                delete new_obj1["MaxValue"];
                break;
            case "MinValue":
                delete new_obj1["MinValue"];
                break;
            default:
                break;
        }
    }
);

let shaped_obj2 = Object.keys(new_obj2).forEach(
    (key, index) =&gt; {
        if(key === "Value"){
            delete new_obj2["Value"];
        }
    }
);</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 12 people.</p><div class="s-prose js-post-body"><h1>Property Removal in JavaScript</h1>

<p>There are many different options presented on this page, not because most of the options are wrong—or because the answers are duplicates—but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</p>

<ol>
<li>The version of ECMAScript you're targeting</li>
<li>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</li>
<li>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</li>
<li>Are you looking to achieve this in pure JavaScript or are you willing &amp; able to use a 3rd-party library?</li>
</ol>

<p>Once those four queries have been answered, there are essentially four categories of "property removal" in JavaScript to chose from in order to meet your goals. They are:</p>

<h2>Mutative object property deletion, unsafe</h2>

<p>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</p>

<pre><code>'use strict'
const iLikeMutatingStuffDontI = { myNameIs: 'KIDDDDD!', [Symbol.for('amICool')]: true }
delete iLikeMutatingStuffDontI[Symbol.for('amICool')] // true
Object.defineProperty({ myNameIs: 'KIDDDDD!', 'amICool', { value: true, configurable: false })
delete iLikeMutatingStuffDontI['amICool'] // throws
</code></pre>

<p>This category is the oldest, most straightforward &amp; most widely supported category of property removal. It supports <code>Symbol</code> &amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" rel="noreferrer">non-configurable properties in strict mode</a>.</p>

<h2>Rest-based string property omission</h2>

<p>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</p>

<pre><code>const foo = { name: 'KIDDDDD!', [Symbol.for('isCool')]: true }
const { name, ...coolio } = foo // coolio doesn't have "name"
const { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn't account for Symbols :(
</code></pre>

<h2>Mutative object property deletion, safe</h2>

<p>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</p>

<pre><code>'use strict'
const iLikeMutatingStuffDontI = { myNameIs: 'KIDDDDD!', [Symbol.for('amICool')]: true }
Reflect.deleteProperty(iLikeMutatingStuffDontI, Symbol.for('amICool')) // true
Object.defineProperty({ myNameIs: 'KIDDDDD!', 'amICool', { value: true, configurable: false })
Reflect.deleteProperty(iLikeMutatingStuffDontI, 'amICool') // false
</code></pre>

<p>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of <code>Reflect.deleteProperty</code> to do partial application and other functional techniques that aren't possible with <code>delete</code> statements.</p>

<h2>Syntax-based string property omission</h2>

<p>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</p>

<pre><code>const foo = { name: 'KIDDDDD!', [Symbol.for('isCool')]: true }
const { name, ...coolio } = foo // coolio doesn't have "name"
const { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn't account for Symbols :(
</code></pre>

<h2>Library-based property omission</h2>

<p>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp; omitting more than one property in one statement:</p>

<pre><code>const o = require("lodash.omit")
const foo = { [Symbol.for('a')]: 'abc', b: 'b', c: 'c' }
const bar = o(foo, 'a') // "'a' undefined"
const baz = o(foo, [ Symbol.for('a'), 'b' ]) // Symbol supported, more than one prop at a time, "Symbol.for('a') undefined"
</code></pre>
</div><p class="this-has-helped">This answer has helped 12 people.</p><div class="s-prose js-post-body"><p>Here's an ES6 way to remove the entry easily:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*"
};

const removeItem = 'regex';

const { [removeItem]: remove, ...rest } = myObject;

console.log(remove); // "^http://.*"
console.log(rest); // Object { ircEvent: "PRIVMSG", method: "newURI" }</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 11 people.</p><div class="s-prose js-post-body"><p><strong>@johnstock</strong>, we can also use JavaScript's prototyping concept to add method to objects to delete any passed key available in calling object.</p>
<p>Above answers are appreciated.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*"
};

// 1st and direct way 
delete myObject.regex; // delete myObject["regex"]
console.log(myObject); // { ircEvent: 'PRIVMSG', method: 'newURI' }

// 2 way -  by using the concept of JavaScript's prototyping concept
Object.prototype.removeFromObjectByKey = function(key) {
  // If key exists, remove it and return true
  if (this[key] !== undefined) {
    delete this[key]
    return true;
  }
  // Else return false
  return false;
}

var isRemoved = myObject.removeFromObjectByKey('method')
console.log(myObject) // { ircEvent: 'PRIVMSG' }

// More examples
var obj = {
  a: 45,
  b: 56,
  c: 67
}
console.log(obj) // { a: 45, b: 56, c: 67 }

// Remove key 'a' from obj
isRemoved = obj.removeFromObjectByKey('a')
console.log(isRemoved); //true
console.log(obj); // { b: 56, c: 67 }

// Remove key 'd' from obj which doesn't exist
var isRemoved = obj.removeFromObjectByKey('d')
console.log(isRemoved); // false
console.log(obj); // { b: 56, c: 67 }</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 11 people.</p><div class="s-prose js-post-body"><p>You can use a filter like below</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var myObject = {
    "ircEvent": "PRIVMSG",
    "method": "newURI",
    "regex": "^http://.*"
};

// Way 1

let filter1 = {}
  Object.keys({...myObject}).filter(d =&gt; {
  if(d !== 'regex'){
    filter1[d] = myObject[d];
  }
})

console.log(filter1)

// Way 2

let filter2 = Object.fromEntries(Object.entries({...myObject}).filter(d =&gt;
d[0] !== 'regex'
))

console.log(filter2)</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 10 people.</p><div class="s-prose js-post-body"><p>I have used <a href="https://lodash.com/docs/4.17.4#unset" rel="nofollow noreferrer">Lodash &quot;unset&quot;</a> to make it happen for a nested object also... only this needs to write small logic to get the path of the property key which is expected by the <em>omit</em> method.</p>
<ol>
<li>Method which returns the property path as an array</li>
</ol>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var a = {"bool":{"must":[{"range":{"price_index.final_price":{"gt":"450", "lt":"500"}}}, {"bool":{"should":[{"term":{"color_value.keyword":"Black"}}]}}]}};

function getPathOfKey(object,key,currentPath, t){
    var currentPath = currentPath || [];

    for(var i in object){
        if(i == key){
            t = currentPath;
        }
        else if(typeof object[i] == "object"){
            currentPath.push(i)
            return getPathOfKey(object[i], key,currentPath)
        }
    }
    t.push(key);
    return t;
}
document.getElementById("output").innerHTML =JSON.stringify(getPathOfKey(a,"price_index.final_price"))</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div id="output"&gt;

&lt;/div&gt;</code></pre>
</div>
</div>
</p>
<ol>
<li>Then just using <a href="https://lodash.com/docs/4.17.4#unset" rel="nofollow noreferrer">Lodash unset</a> method remove property from object.</li>
</ol>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var unset = require('lodash.unset');
unset(a, getPathOfKey(a, "price_index.final_price"));</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 5 people.</p><div class="s-prose js-post-body"><p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myObject = {
    "ircEvent": "PRIVMSG",
    "method": "newURI",
    "regex": "^http://.*"
};


obj = Object.fromEntries(
    Object.entries(myObject).filter(function (m){
        return m[0] != "regex"/*or whatever key to delete*/
    }
))

console.log(obj)</code></pre>
</div>
</div>
</p>
<p>You can also just treat the object like <code>a2d</code> array using <code>Object.entries</code>, and use splice to remove an element as you would in a normal array, or simply filter through the object, as one would an array, and assign the reconstructed object back to the original variable</p>
</div><p class="this-has-helped">This answer has helped 5 people.</p><div class="s-prose js-post-body"><p>If you don't want to modify the original object.</p>
<p><strong>Remove a property without mutating the object</strong></p>
<p>If mutability is a concern, you can create a completely new object by copying all the properties from the old, except the one you want to remove.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myObject = {
  "ircEvent": "PRIVMSG",
  "method": "newURI",
  "regex": "^http://.*"
};

let prop = 'regex';
const updatedObject = Object.keys(myObject).reduce((object, key) =&gt; {
  if (key !== prop) {
    object[key] = myObject[key]
  }
  return object
}, {})

console.log(updatedObject);</code></pre>
</div>
</div>
</p>
</div></body></html>