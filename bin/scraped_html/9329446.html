<!DOCTYPE html><html lang="en"><head><style>@import url("https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;1,200;1,300&family=Work+Sans:wght@400;500&display=swap");</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><head><link href="../../src/css/general.css" rel="stylesheet" /></head><p class='question-hyperlink'>Loop (for each) over an array in JavaScript</p><div class="s-prose js-post-body"><p>How can I loop through all the entries in an array using JavaScript?</p>
</div><p class="this-has-helped">This answer has helped 8237 people.</p><div class="s-prose js-post-body">
<p><strong>TL;DR</strong></p>
<ul>
<li><p><strong>Your best bets</strong> are usually</p>
<ul>
<li>a <code>for-of</code> loop (ES2015+ only; <a href="https://tc39.es/ecma262/#sec-for-in-and-for-of-statements" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer">MDN</a>) - simple and <code>async</code>-friendly
<pre class="lang-js prettyprint-override"><code>for (const element of theArray) {
    // ...use `element`...
}
</code></pre>
</li>
<li><code>forEach</code> (ES5+ only; <a href="https://tc39.es/ecma262/#sec-array.prototype.foreach" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer">MDN</a>) (or its relatives <code>some</code> and such) - <strong>not</strong> <code>async</code>-friendly (but see details)
<pre class="lang-js prettyprint-override"><code>theArray.forEach(element =&gt; {
    // ...use `element`...
});
</code></pre>
</li>
<li>a simple old-fashioned <code>for</code> loop - <code>async</code>-friendly
<pre class="lang-js prettyprint-override"><code>for (let index = 0; index &lt; theArray.length; ++index) {
    const element = theArray[index];
    // ...use `element`...
}
</code></pre>
</li>
<li><em>(rarely)</em> <code>for-in</code> <em>with safeguards</em> - <code>async</code>-friendly
<pre class="lang-js prettyprint-override"><code>for (const propertyName in theArray) {
    if (/*...is an array element property (see below)...*/) {
        const element = theArray[propertyName];
        // ...use `element`...
    }
}
</code></pre>
</li>
</ul>
</li>
<li><p>Some quick &quot;don't&quot;s:</p>
<ul>
<li><strong>Don't use <code>for-in</code></strong> unless you use it with safeguards or are at least aware of why it might bite you.</li>
<li><strong>Don't use <code>map</code> if you're not using its return value</strong>.<br><em>(There's sadly someone out there teaching <code>map</code> [<a href="https://tc39.es/ecma262/#sec-array.prototype.map" rel="noreferrer">spec</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noreferrer">MDN</a>] as though it were <code>forEach</code> — but as I write on my blog, <a href="https://thenewtoys.dev/blog/2021/04/17/misusing-map/" rel="noreferrer">that's not what it's for</a>. If you aren't using the array it creates, don't use <code>map</code>.)</em></li>
<li><strong>Don't use <code>forEach</code></strong> if the callback does asynchronous work and you want the <code>forEach</code> to wait until that work is done (because it won't).</li>
</ul>
</li>
</ul>
<p>But there's <strong>lots</strong> more to explore, read on...</p>
<hr />
<p>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-<em>like</em>, such as the <code>arguments</code> object, other iterable objects (ES2015+), DOM collections, and so on.</p>
<p>Okay, let's look at our options:</p>
<h2>For Actual Arrays</h2>
<p>You have five options (two supported basically forever, another added by ECMAScript 5 [&quot;ES5&quot;], and two more added in ECMAScript 2015 (&quot;ES2015&quot;, aka &quot;ES6&quot;):</p>
<ol>
<li>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</li>
<li>Use <code>forEach</code> and related (ES5+)</li>
<li>Use a simple <code>for</code> loop</li>
<li>Use <code>for-in</code> <em>correctly</em></li>
<li>Use an iterator explicitly (ES2015+)</li>
</ol>
<p>(You can see those old specs here: <a href="http://ecma-international.org/ecma-262/5.1/" rel="noreferrer">ES5</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noreferrer">ES2015</a>, but both have been superceded; the current editor's draft is always <a href="https://tc39.github.io/ecma262/" rel="noreferrer">here</a>.)</p>
<p>Details:</p>
<h3>1. Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</h3>
<p>ES2015 added <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer"><em>iterators and iterables</em></a> to JavaScript. Arrays are iterable (so are strings, <code>Map</code>s, and <code>Set</code>s, as well as DOM collections and lists, as you'll see later). Iterable objects provide iterators for their values. The new <code>for-of</code> statement loops through the values returned by an iterator:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (const element of a) { // You can use `let` instead of `const` if you like
    console.log(element);
}
// a
// b
// c</code></pre>
</div>
</div>
</p>
<p>It doesn't get simpler than that! Under the covers, that gets an iterator from the array and loops through the values the iterator returns. The iterator provided by arrays provides the values of the array elements, in order beginning to end.</p>
<p>Notice how <code>element</code> is scoped to each loop iteration; trying to use <code>element</code> after the end of the loop would fail because it doesn't exist outside the loop body.</p>
<p>In theory, a <code>for-of</code> loop involves several function calls (one to get the iterator, then one to get each value from it). Even when that's true, it's nothing to worry about, function calls are <em><strong>very</strong></em> cheap in modern JavaScript engines (it bothered me for <code>forEach</code> [below] until I looked into it; <a href="http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html" rel="noreferrer">details</a>). But additionally, JavaScript engines optimize those calls away (in performance-critical code) when dealing with native iterators for things like arrays.</p>
<p><code>for-of</code> is entirely <code>async</code>-friendly. If you need the work in a loop body to be done in series (not in parallel), an <code>await</code> in the loop body will wait for the promise to settle before continuing. Here's a silly example:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (const message of messages) {
        await delay(400);
        console.log(message);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
</div>
</div>
</p>
<p>Note how the words appear with a delay before each one.</p>
<p>It's a matter of coding style, but <code>for-of</code> is the first thing I reach for when looping through anything iterable.</p>
<h3>2. Use <code>forEach</code> and related</h3>
<p>In any even vaguely-modern environment (so, not IE8) where you have access to the <code>Array</code> features added by ES5, you can use <code>forEach</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.foreach" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer">MDN</a>) if you're only dealing with synchronous code (or you don't need to wait for an asynchronous process to finish during the loop):</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
a.forEach((element) =&gt; {
    console.log(element);
});</code></pre>
</div>
</div>
</p>
<p><code>forEach</code> accepts a callback function and, optionally, a value to use as <code>this</code> when calling that callback (not used above). The callback is called for each element in the array, in order, skipping non-existent elements in sparse arrays. Although I only used one parameter above, the callback is called with three arguments: The element for that iteration, the index of that element, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</p>
<p>Like <code>for-of</code>, <code>forEach</code> has the advantage that you don't have to declare indexing and value variables in the containing scope; in this case, they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</p>
<p>Unlike <code>for-of</code>, <code>forEach</code> has the disadvantage that it doesn't understand <code>async</code> functions and <code>await</code>. If you use an <code>async</code> function as the callback, <code>forEach</code> does <strong>not</strong> wait for that function's promise to settle before continuing. Here's the <code>async</code> example from <code>for-of</code> using <code>forEach</code> instead — notice how there's an initial delay, but then all the text appears right away instead of waiting:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    // INCORRECT, doesn't wait before continuing,
    // doesn't handle promise rejections
    messages.forEach(async message =&gt; {
        await delay(400);
        console.log(message);
    });
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
</div>
</div>
</p>
<p><code>forEach</code> is the &quot;loop through them all&quot; function, but ES5 defined several other useful &quot;work your way through the array and do things&quot; functions, including:</p>
<ul>
<li><code>every</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.every" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noreferrer">MDN</a>) - stops looping the first time the callback returns a falsy value</li>
<li><code>some</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.some" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noreferrer">MDN</a>) - stops looping the first time the callback returns a truthy value</li>
<li><code>filter</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.filter" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noreferrer">MDN</a>) - creates a new array including elements where the callback returns a truthy value, omitting the ones where it doesn't</li>
<li><code>map</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.map" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noreferrer">MDN</a>) - creates a new array from the values returned by the callback</li>
<li><code>reduce</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.reduce" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noreferrer">MDN</a>) - builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details</li>
<li><code>reduceRight</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.reduceright" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight" rel="noreferrer">MDN</a>) - like <code>reduce</code>, but works in descending rather than ascending order</li>
</ul>
<p>As with <code>forEach</code>, if you use an <code>async</code> function as your callback, none of those waits for the function's promise to settle. That means:</p>
<ul>
<li>Using an <code>async</code> function callback is never appropriate with <code>every</code>, <code>some</code>, and <code>filter</code> since they will treat the returned promise as though it were a truthy value; they <strong>don't</strong> wait for the promise to settle and then use the fulfillment value.</li>
<li>Using an <code>async</code> function callback is often appropriate with <code>map</code>, <strong>if</strong> the goal is to turn an array of something into an array of <em>promises</em>, perhaps for passing to one of the promise combinator functions (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noreferrer"><code>Promise.all</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noreferrer"><code>Promise.race</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noreferrer"><code>promise.allSettled</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" rel="noreferrer"><code>Promise.any</code></a>).</li>
<li>Using an <code>async</code> function callback is rarely appropriate with <code>reduce</code> or <code>reduceRight</code>, because (again) the callback will always return a promise. But there is an idiom of building a chain of promises from an array that uses <code>reduce</code> (<code>const promise = array.reduce((p, element) =&gt; p.then(/*...something using `element`...*/));</code>), but usually in those cases a <code>for-of</code> or <code>for</code> loop in an <code>async</code> function will be clearer and easier to debug.</li>
</ul>
<h3>3. Use a simple <code>for</code> loop</h3>
<p>Sometimes the old ways are the best:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = 0; index &lt; a.length; ++index) {
    const element = a[index];
    console.log(element);
}</code></pre>
</div>
</div>
</p>
<p>If the length of the array won't change during the loop, and it's in highly performance-sensitive code, a slightly more complicated version grabbing the length up front might be a <em><strong>tiny</strong></em> bit faster:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = 0, len = a.length; index &lt; len; ++index) {
    const element = a[index];
    console.log(element);
}</code></pre>
</div>
</div>
</p>
<p>And/or counting backward:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = a.length - 1; index &gt;= 0; --index) {
    const element = a[index];
    console.log(element);
}</code></pre>
</div>
</div>
</p>
<p>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</p>
<p>Before ES2015, the loop variable had to exist in the containing scope, because <code>var</code> only has function-level scope, not block-level scope. But as you saw in the examples above, you can use <code>let</code> within the <code>for</code> to scope the variables to just the loop. And when you do that, the <code>index</code> variable is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the <code>index</code> for that specific iteration, which solves the old &quot;closures in loops&quot; problem:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// (The `NodeList` from `querySelectorAll` is array-like)
const divs = document.querySelectorAll("div");
for (let index = 0; index &lt; divs.length; ++index) {
    divs[index].addEventListener('click', e =&gt; {
        console.log("Index is: " + index);
    });
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;zero&lt;/div&gt;
&lt;div&gt;one&lt;/div&gt;
&lt;div&gt;two&lt;/div&gt;
&lt;div&gt;three&lt;/div&gt;
&lt;div&gt;four&lt;/div&gt;</code></pre>
</div>
</div>
</p>
<p>In the above, you get &quot;Index is: 0&quot; if you click the first and &quot;Index is: 4&quot; if you click the last. This does <strong>not</strong> work if you use <code>var</code> instead of <code>let</code> (you'd always see &quot;Index is: 5&quot;).</p>
<p>Like <code>for-of</code>, <code>for</code> loops work well in <code>async</code> functions. Here's the earlier example using a <code>for</code> loop:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (let i = 0; i &lt; messages.length; ++i) {
        const message = messages[i];
        await delay(400);
        console.log(message);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
</div>
</div>
</p>
<h3>4. Use <code>for-in</code> <em>correctly</em></h3>
<p><code>for-in</code> isn't for looping through arrays, it's for looping through the names of an object's properties. It does often seem to work for looping through arrays as a by-product of the fact that arrays are objects, but it doesn't just loop through the array indexes, it loops through <strong>all</strong> enumerable properties of the object (including inherited ones). (It also used to be that the order wasn't specified; it is now [details in <a href="https://stackoverflow.com/a/30919039/157247">this other answer</a>], but even though the order is specified now, the rules are complex, there are exceptions, and relying on the order is not best practice.)</p>
<p>The only real use cases for <code>for-in</code> on an array are:</p>
<ul>
<li>It's a <a href="http://en.wikipedia.org/wiki/Sparse_array" rel="noreferrer"><em>sparse</em> array</a> with <strong>massive</strong> gaps in it, or</li>
<li>You're using non-element properties on the array object and you want to include them in the loop</li>
</ul>
<p>Looking only at that first example: You can use <code>for-in</code> to visit those sparse array elements if you use appropriate safeguards:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// `a` is a sparse array
const a = [];
a[0] = "a";
a[10] = "b";
a[10000] = "c";
for (const name in a) {
    if (Object.hasOwn(a, name) &amp;&amp;       // These checks are
        /^0$|^[1-9]\d*$/.test(name) &amp;&amp;  // explained
        name &lt;= 4294967294              // below
       ) {
        const element = a[name];
        console.log(a[name]);
    }
}</code></pre>
</div>
</div>
</p>
<p>Note the three checks:</p>
<ol>
<li><p>That the object has its <em>own</em> property by that name (not one it inherits from its prototype; this check is also often written as <code>a.hasOwnProperty(name)</code> but ES2022 adds <a href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noreferrer"><code>Object.hasOwn</code></a> which can be more reliable), and</p>
</li>
<li><p>That the name is all decimal digits (e.g., normal string form, not scientific notation), and</p>
</li>
<li><p>That the name's value when coerced to a number is &lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index <a href="https://tc39.es/ecma262/#array-index" rel="noreferrer">in the specification</a>. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - <strong>2</strong> is that that makes the greatest index value one lower than 2^32 - <strong>1</strong>, which is the maximum value an array's <code>length</code> can have. (E.g., an array's length fits in a 32-bit unsigned integer.)</p>
</li>
</ol>
<p>...although with that said, most code only does the <code>hasOwnProperty</code> check.</p>
<p>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// Utility function for antiquated environments without `forEach`
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
const rexNum = /^0$|^[1-9]\d*$/;
function sparseEach(array, callback, thisArg) {
    for (const name in array) {
        const index = +name;
        if (hasOwn(a, name) &amp;&amp;
            rexNum.test(name) &amp;&amp;
            index &lt;= 4294967294
           ) {
            callback.call(thisArg, array[name], index, array);
        }
    }
}

const a = [];
a[5] = "five";
a[10] = "ten";
a[100000] = "one hundred thousand";
a.b = "bee";

sparseEach(a, (value, index) =&gt; {
    console.log("Value at " + index + " is " + value);
});</code></pre>
</div>
</div>
</p>
<p>Like <code>for</code>, <code>for-in</code> works well in asynchronous functions if the work within it needs to be done in series.</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (const name in messages) {
        if (messages.hasOwnProperty(name)) { // Almost always this is the only check people do
            const message = messages[name];
            await delay(400);
            console.log(message);
        }
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
</div>
</div>
</p>
<h3>5. Use an iterator explicitly (ES2015+)</h3>
<p><code>for-of</code> uses an iterator implicitly, doing all the scut work for you. Sometimes, you might want to use an iterator <em>explicitly</em>. It looks like this:</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
const it = a.values(); // Or `const it = a[Symbol.iterator]();` if you like
let entry;
while (!(entry = it.next()).done) {
    const element = entry.value;
    console.log(element);
}</code></pre>
</div>
</div>
</p>
<p>An iterator is an object matching the Iterator definition in the specification. Its <code>next</code> method returns a new <em>result object</em> each time you call it. The result object has a property, <code>done</code>, telling us whether it's done, and a property <code>value</code> with the value for that iteration. (<code>done</code> is optional if it would be <code>false</code>, <code>value</code> is optional if it would be <code>undefined</code>.)</p>
<p>What you get for <code>value</code> varies depending on the iterator. On arrays, the default iterator provides the value of each array element (<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, and <code>&quot;c&quot;</code> in the example earlier). Arrays also have three other methods that return iterators:</p>
<ul>
<li><code>values()</code>: This is an alias for the <code>[Symbol.iterator]</code> method that returns the default iterator.</li>
<li><code>keys()</code>: Returns an iterator that provides each key (index) in the array. In the example above, it would provide <code>&quot;0&quot;</code>, then <code>&quot;1&quot;</code>, then <code>&quot;2&quot;</code> (yes, as strings).</li>
<li><code>entries()</code>: Returns an iterator that provides <code>[key, value]</code> arrays.</li>
</ul>
<p>Since iterator objects don't advance until you call <code>next</code>, they work well in <code>async</code> function loops. Here's the earlier <code>for-of</code> example using the iterator explicitly:</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    const it = messages.values()
    while (!(entry = it.next()).done) {
        await delay(400);
        const element = entry.value;
        console.log(element);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
</div>
</div>
</p>
<h2>For Array-Like Objects</h2>
<p>Aside from true arrays, there are also <em>array-like</em> objects that have a <code>length</code> property and properties with all-digits names: <a href="https://dom.spec.whatwg.org/#interface-nodelist" rel="noreferrer"><code>NodeList</code> instances</a>, <a href="https://dom.spec.whatwg.org/#interface-htmlcollection" rel="noreferrer"><code>HTMLCollection</code> instances</a>, the <code>arguments</code> object, etc. How do we loop through their contents?</p>
<h3>Use most of the options above</h3>
<p>At least some, and possibly most or even all, of the array approaches above apply equally well to array-like objects:</p>
<ol>
<li><p><strong>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</strong></p>
<p><code>for-of</code> uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (if any). That includes host-provided objects (like DOM collections and lists). For instance, <code>HTMLCollection</code> instances from <code>getElementsByXYZ</code> methods and <code>NodeList</code>s instances from <code>querySelectorAll</code> both support iteration. (This is defined <strong>quite</strong> subtly by the HTML and DOM specifications. Basically, any object with <code>length</code> and indexed access is automatically iterable. It <strong>doesn't</strong> have to be marked <code>iterable</code>; that is used only for collections that, in addition to being iterable, support <code>forEach</code>, <code>values</code>, <code>keys</code>, and <code>entries</code> methods. <code>NodeList</code> does; <code>HTMLCollection</code> doesn't, but both are iterable.)</p>
<p>Here's an example of looping through <code>div</code> elements:</p>
</li>
</ol>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const divs = document.querySelectorAll("div");
for (const div of divs) {
    div.textContent = Math.random();
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;zero&lt;/div&gt;
&lt;div&gt;one&lt;/div&gt;
&lt;div&gt;two&lt;/div&gt;
&lt;div&gt;three&lt;/div&gt;
&lt;div&gt;four&lt;/div&gt;</code></pre>
</div>
</div>
</p>
<ol start="2">
<li><p><strong>Use <code>forEach</code> and related (ES5+)</strong></p>
<p>The various functions on <code>Array.prototype</code> are &quot;intentionally generic&quot; and can be used on array-like objects via <code>Function#call</code> (<a href="https://tc39.es/ecma262/#sec-function.prototype.call" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noreferrer">MDN</a>) or <code>Function#apply</code> (<a href="https://tc39.es/ecma262/#sec-function.prototype.apply" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noreferrer">MDN</a>). (If you have to deal with IE8 or earlier [ouch], see the &quot;Caveat for host-provided objects&quot; at the end of this answer, but it's not an issue with vaguely-modern browsers.)</p>
<p>Suppose you wanted to use <code>forEach</code> on a <code>Node</code>'s <code>childNodes</code> collection (which, being an <code>HTMLCollection</code>, doesn't have <code>forEach</code> natively). You'd do this:</p>
<pre><code>Array.prototype.forEach.call(node.childNodes, (child) =&gt; {
    // Do something with `child`
});
</code></pre>
<p>(Note, though, that you could just use <code>for-of</code> on <code>node.childNodes</code>.)</p>
<p>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</p>
<pre><code>// (This is all presumably in a module or some scoping function)
const forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

// Then later...
forEach(node.childNodes, (child) =&gt; {
    // Do something with `child`
});
</code></pre>
</li>
<li><p><strong>Use a simple <code>for</code> loop</strong></p>
<p>Perhaps obviously, a simple <code>for</code> loop works for array-like objects.</p>
</li>
<li><p><strong>Use an iterator explicitly (ES2015+)</strong></p>
<p>See #1.</p>
</li>
</ol>
<p>You <em><strong>may</strong></em> be able to get away with <code>for-in</code> (with safeguards), but with all of these more appropriate options, there's no reason to try.</p>
<h3>Create a true array</h3>
<p>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</p>
<ol>
<li><p><strong>Use <code>Array.from</code></strong></p>
<p><code>Array.from</code> <a href="https://tc39.es/ecma262/#sec-array.from" rel="noreferrer">(spec)</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noreferrer">(MDN)</a> (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</p>
<pre><code>const divs = Array.from(document.querySelectorAll(&quot;div&quot;));
</code></pre>
<p>...takes the <code>NodeList</code> from <code>querySelectorAll</code> and makes an array from it.</p>
<p>The mapping function is handy if you were going to map the contents in some way. For instance, if you wanted to get an array of the tag names of the elements with a given class:</p>
<pre><code>// Typical use (with an arrow function):
const divs = Array.from(document.querySelectorAll(&quot;.some-class&quot;), element =&gt; element.tagName);

// Traditional function (since `Array.from` can be polyfilled):
var divs = Array.from(document.querySelectorAll(&quot;.some-class&quot;), function(element) {
    return element.tagName;
});
</code></pre>
</li>
<li><p><strong>Use spread syntax (<code>...</code>)</strong></p>
<p>It's also possible to use ES2015's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread syntax</a>. Like <code>for-of</code>, this uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (see #1 in the previous section):</p>
<pre><code>const trueArray = [...iterableObject];
</code></pre>
<p>So for instance, if we want to convert a <code>NodeList</code> into a true array, with spread syntax this becomes quite succinct:</p>
<pre><code>const divs = [...document.querySelectorAll(&quot;div&quot;)];
</code></pre>
</li>
<li><p><strong>Use the <code>slice</code> method of arrays</strong></p>
<p>We can use the <a href="https://tc39.es/ecma262/#sec-array.prototype.slice" rel="noreferrer"><code>slice</code></a> method of arrays, which like the other methods mentioned above is &quot;intentionally generic&quot; and so can be used with array-like objects, like this:</p>
<pre><code>const trueArray = Array.prototype.slice.call(arrayLikeObject);
</code></pre>
<p>So for instance, if we want to convert a <code>NodeList</code> into a true array, we could do this:</p>
<pre><code>const divs = Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));
</code></pre>
<p>(If you still have to handle IE8 [ouch], will fail; IE8 didn't let you use host-provided objects as <code>this</code> like that.)</p>
</li>
</ol>
<h3>Caveat for host-provided objects</h3>
<p>If you use <code>Array.prototype</code> functions with <em>host-provided</em> array-like objects (for example, DOM collections and such provided by the browser rather than the JavaScript engine), obsolete browsers like IE8 didn't necessarily handle that way, so if you have to support them, be sure to test in your target environments. But it's not an issue with vaguely-modern browsers. (For non-browser environments, naturally it'll depend on the environment.)</p>
</div><p class="this-has-helped">This answer has helped 567 people.</p><div class="s-prose js-post-body"><p><strong>Note</strong>: This answer is hopelessly out-of-date. For a more modern approach, look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">the methods available on an array</a>. Methods of interest might be:</p>

<ul>
<li>forEach</li>
<li>map</li>
<li>filter</li>
<li>zip</li>
<li>reduce</li>
<li>every</li>
<li>some</li>
</ul>

<hr>

<p>The standard way to iterate an array in <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a> is a vanilla <code>for</code>-loop:</p>

<pre><code>var length = arr.length,
    element = null;
for (var i = 0; i &lt; length; i++) {
  element = arr[i];
  // Do something with element
}
</code></pre>

<p>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not <em>really</em> exist in the array. In this case, a <code>for .. in</code>-loop might be a better idea. <strong>However</strong>, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the <code>for..in</code>-loop will also be enumerated in legacy browsers, or if the additional properties are defined as <code>enumerable</code>.</p>

<p>In <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, <a href="http://en.wikipedia.org/wiki/Node.js" rel="noreferrer">Node.js</a> for server side JavaScript), or use a "Polyfill". The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</p>
</div><p class="this-has-helped">This answer has helped 272 people.</p><div class="s-prose js-post-body"><p>If you’re using the <a href="http://jquery.com/" rel="noreferrer"><strong>jQuery</strong></a> library, you can use <a href="http://api.jquery.com/jQuery.each/" rel="noreferrer"><strong>jQuery.each</strong></a>:</p>



<pre class="lang-js prettyprint-override"><code>$.each(yourArray, function(index, value) {
  // do your stuff here
});
</code></pre>

<p><strong>EDIT :</strong> </p>

<p>As per question, user want code in javascript instead of jquery so the edit is</p>

<pre class="lang-js prettyprint-override"><code>var length = yourArray.length;   
for (var i = 0; i &lt; length; i++) {
  // Do something with yourArray[i].
}
</code></pre>
</div><p class="this-has-helped">This answer has helped 149 people.</p><div class="s-prose js-post-body"><h1>Loop backwards</h1>

<p>I think the <em>reverse</em> for loop deserves a mention here:</p>

<pre><code>for (var i = array.length; i--; ) {
     // process array[i]
}
</code></pre>

<h2>Advantages:</h2>

<ul>
<li>You do not need to declare a temporary <code>len</code> variable, or compare against <code>array.length</code> on each iteration, either of which might be a minute optimisation.</li>
<li><strong>Removing siblings</strong> from the DOM in reverse order is usually <strong>more efficient</strong>.  (The browser needs to do less shifting of elements in its internal arrays.)</li>
<li>If you <strong>modify the array</strong> while looping, at or after index <em>i</em> (for example you remove or insert an item at <code>array[i]</code>), then a forward loop would skip the item that shifted left into position <em>i</em>, or re-process the <em>i</em>th item that was shifted right.  In a traditional for loop, you <em>could</em> update <em>i</em> to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a <strong>simpler</strong> and <a href="https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450">more elegant solution</a>.</li>
<li>Similarly, when modifying or removing <strong>nested</strong> DOM elements, processing in reverse can <strong>circumvent errors</strong>. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</li>
<li>It is <strong>shorter</strong> to type, and <strong>read</strong>, than some of the other options available.  Although it loses to <code>forEach()</code> and to ES6's <code>for ... of</code>.</li>
</ul>

<h2>Disadvantages:</h2>

<ul>
<li>It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally <strong>the output will be reversed</strong> with respect to the original order.</li>
<li>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is <strong>less efficient</strong>.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a "document fragment").</li>
<li>The reverse loop is <strong>confusing</strong> to junior developers.  (You may consider that an advantage, depending on your outlook.)</li>
</ul>

<hr>

<h2>Should I always use it?</h2>

<p>Some developers use the reverse for loop <em>by default</em>, unless there is a good reason to loop forwards.</p>

<p>Although the performance gains are usually insignificant, it sort of screams:</p>

<blockquote>
  <p>"Just do this to every item in the list, I don't care about the order!"</p>
</blockquote>

<p>However in practice that is <strong>not</strong> actually a reliable indication of intent, since it is indistinguishable from those occasions when you <strong><em>do</em></strong> care about the order, and really do <strong><em>need</em></strong> to loop in reverse.  So in fact another construct would be needed to accurately express the "don't care" intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, <code>forEachUnordered()</code>.</p>

<p>If order doesn't matter, and <strong>efficiency</strong> is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code <strong>does not necessarily mean</strong> that the order irrelevant!</p>

<h3>It was better to use forEach()</h3>

<p>In general for higher level code where <strong>clarity and safety</strong> are greater concerns, I previously recommended using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>Array::forEach</code></a> as your default pattern for looping (although these days I prefer to use <code>for..of</code>).  Reasons to prefer <code>forEach</code> over a reverse loop are:</p>

<ul>
<li>It is clearer to read.</li>
<li>It indicates that <em>i</em> is not going to be shifted within the block (which is always a possible surprise hiding in long <code>for</code> and <code>while</code> loops).</li>
<li>It gives you a free scope for closures.</li>
<li>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</li>
</ul>

<p>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.</p>

<p>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on <a href="https://www.youtube.com/watch?v=taaEzHI9xyY&amp;t=480" rel="noreferrer">Programming Style &amp; Your Brain</a>.)</p>

<h3>It is now even better to use for..of!</h3>

<p>There is a debate about whether <code>for..of</code> or <code>forEach()</code> are preferable:</p>

<ul>
<li><p>For maximum browser support, <code>for..of</code> <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142" rel="noreferrer">requires a polyfill</a> for iterators, making your app slightly slower to execute and slightly larger to download.</p></li>
<li><p>For that reason (and to encourage use of <code>map</code> and <code>filter</code>), <a href="https://github.com/airbnb/javascript#iterators-and-generators" rel="noreferrer">some front-end style guides</a> ban <code>for..of</code> completely!</p></li>
<li><p>But the above concerns is not applicable to Node.js applications, where <code>for..of</code> is now well supported.</p></li>
<li><p>And furthermore <code>await</code> <a href="https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971" rel="noreferrer">does not work</a> inside <code>forEach()</code>.  Using <code>for..of</code> is <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436" rel="noreferrer">the clearest pattern</a> in this case.</p></li>
</ul>

<p>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use <code>for..of</code> instead of <code>forEach()</code>, but I will always use <code>map</code> or <code>filter</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noreferrer"><code>find</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noreferrer"><code>some</code></a> when applicable. 
 (For the sake of my colleagues, I rarely use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noreferrer"><code>reduce</code></a>.)</p>

<hr>

<h2>How does it work?</h2>

<pre><code>for (var i = 0; i &lt; array.length; i++) { ... }   // Forwards

for (var i = array.length; i--; )    { ... }   // Reverse
</code></pre>

<p>You will notice that <code>i--</code> is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see <code>i++</code>).  That means that <code>i--</code> is also used as the <em>condition</em> for continuation.  Crucially, it is executed and checked <em>before</em> each iteration.</p>

<ul>
<li><p><strong>How can it start at <code>array.length</code> without exploding?</strong></p>

<p>Because <code>i--</code> runs <em>before</em> each iteration, on the first iteration we will actually be accessing the item at <code>array.length - 1</code> which avoids any issues with <strike>Array-out-of-bounds</strike> <code>undefined</code> items.</p></li>
<li><p><strong>Why doesn't it stop iterating before index 0?</strong></p>

<p>The loop will stop iterating when the condition <code>i--</code> evaluates to a falsey value (when it yields 0).</p>

<p>The trick is that unlike <code>--i</code>, the trailing <code>i--</code> operator decrements <code>i</code> but yields the value <strong><em>before</em></strong> the decrement.  Your console can demonstrate this:</p>

<p><code>&gt; var i = 5; [i, i--, i];</code></p>

<p><code>[5, 5, 4]</code></p>

<p>So on the final iteration, <em>i</em> was previously <strong>1</strong> and the <code>i--</code> expression changes it to <strong>0</strong> but actually yields <strong>1</strong> (truthy), and so the condition passes.  On the next iteration <code>i--</code> changes <em>i</em> to <strong>-1</strong> but yields <strong>0</strong> (falsey), causing execution to immediately drop out of the bottom of the loop.</p>

<p>In the traditional forwards for loop, <code>i++</code> and <code>++i</code> are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with <code>i--</code> if we want to process the item at index 0.</p></li>
</ul>

<hr>

<h2>Trivia</h2>

<p>Some people like to draw a little arrow in the reverse <code>for</code> loop, and end with a wink:</p>

<pre><code>for (var i = array.length; i --&gt; 0 ;) {
</code></pre>

<hr>

<p><em>Credits go to WYL for showing me the benefits and horrors of the reverse for loop.</em></p>
</div><p class="this-has-helped">This answer has helped 99 people.</p><div class="s-prose js-post-body"><p>Some <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29" rel="noreferrer">C</a>-style languages use <code>foreach</code> to loop through enumerations. In JavaScript this is done with the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code> loop structure</a>:</p>

<pre><code>var index,
    value;
for (index in obj) {
    value = obj[index];
}
</code></pre>

<p>There is a catch. <code>for..in</code> will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</p>

<pre><code>for (i in obj) {
    if (obj.hasOwnProperty(i)) {
        //do stuff
    }
}
</code></pre>

<p>Additionally, <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> has added a <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>forEach</code></a> method to <code>Array.prototype</code> which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</p>

<pre><code>arr.forEach(function (val, index, theArray) {
    //do stuff
});
</code></pre>

<p>It's important to note that <code>Array.prototype.forEach</code> doesn't break when the callback returns <code>false</code>. <a href="http://en.wikipedia.org/wiki/JQuery" rel="noreferrer">jQuery</a> and <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a> provide their own variations on <code>each</code> to provide loops that can be short-circuited.</p>
</div><p class="this-has-helped">This answer has helped 77 people.</p><div class="s-prose js-post-body"><h1>for...of &nbsp; | &nbsp; forEach &nbsp; | &nbsp; map</h1>
<h3>Using modern JavaScript syntax to iterate through arrays</h3>
<pre><code>const fruits = ['🍎', '🍋', '🍌' ]
</code></pre>
<p>👉🏽   for...of</p>
<pre><code>for (const fruit of fruits) {
    console.log(fruit)  // '🍎', '🍋', '🍌'
}
</code></pre>
<p>👉🏽   forEach</p>
<pre><code>fruits.forEach(fruit =&gt; {
    console.log(fruit)  // '🍎', '🍋', '🍌'
})
</code></pre>
<p>👉🏽   map</p>
<p>*Different from the two above, map() <em>creates</em> a new array and expects you to <em>return</em> something after each iteration.</p>
<pre><code>fruits.map(fruit =&gt; fruit)   // ['🍎', '🍋', '🍌' ]
</code></pre>
<p>🛑  <em><strong>Important</strong></em>: As <strong>map()</strong> is meant to return a value at each iteration, it is an ideal method for transforming elements in arrays:</p>
<pre><code>fruits.map(fruit =&gt; 'cool ' + fruit)   // ['cool 🍎', 'cool 🍋', 'cool 🍌' ]
</code></pre>
<p>On the other hand, <b>for...of</b> and <b>forEach( )</b> don't need to return anything and that's why we typically use them to perform logic tasks that manipulate stuff outside.</p>
<p>So to speak, you're going to find if () statements, side effects, and logging activities in these two.</p>
<p>👌🏾  TIP: you can also have the index (as well as the whole array) in each iteration in your .map() or .forEach() functions.</p>
<p>Just pass additional arguments to them:</p>
<pre><code>fruits.map((fruit, i) =&gt;  i + '  ' + fruit)

// ['0 🍎', '1 🍋', '2 🍌' ]

fruits.forEach((f, i, arr) =&gt; {
    console.log( f + ' ' + i + ' ' +  arr )
})

// 🍎  0  🍎, 🍋, 🍌,
// 🍋  1  🍎, 🍋, 🍌,
// 🍌  2  🍎, 🍋, 🍌,
</code></pre>
</div><p class="this-has-helped">This answer has helped 55 people.</p><div class="s-prose js-post-body"><p>If you want to loop over an array, use the standard three-part <code>for</code> loop.</p>

<pre><code>for (var i = 0; i &lt; myArray.length; i++) {
    var arrayItem = myArray[i];
}
</code></pre>

<p>You can get some performance optimisations by caching <code>myArray.length</code> or iterating over it backwards.</p>
</div><p class="this-has-helped">This answer has helped 43 people.</p><div class="s-prose js-post-body"><p>If you don't mind emptying the array:</p>

<pre><code>var x;

while(x = y.pop()){ 

    alert(x); //do something 

}
</code></pre>

<p><code>x</code> will contain the last value of <code>y</code> and it will be removed from the array. You can also use <code>shift()</code> which will give and remove the first item from <code>y</code>.</p>
</div><p class="this-has-helped">This answer has helped 40 people.</p><div class="s-prose js-post-body"><p>A <strong>forEach</strong> implementation (<a href="http://jsfiddle.net/nmoliveira/zNsyB/" rel="noreferrer">see in jsFiddle</a>):</p>

<pre><code>function forEach(list,callback) {
  var length = list.length;
  for (var n = 0; n &lt; length; n++) {
    callback.call(list[n]);
  }
}

var myArray = ['hello','world'];

forEach(
  myArray,
  function(){
    alert(this); // do something
  }
);
</code></pre>
</div><p class="this-has-helped">This answer has helped 40 people.</p><div class="s-prose js-post-body"><p>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using <a href="https://angularjs.org/" rel="noreferrer">AngularJS</a>. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</p>

<p><code>angular.forEach</code> takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</p>

<p>There are different ways to use the forEach loop of angular. The simplest and probably most used is</p>

<pre><code>var temp = [1, 2, 3];
angular.forEach(temp, function(item) {
    //item will be each element in the array
    //do something
});
</code></pre>

<p>Another way that is useful for copying items from one array to another is</p>

<pre><code>var temp = [1, 2, 3];
var temp2 = [];
angular.forEach(temp, function(item) {
    this.push(item); //"this" refers to the array passed into the optional third parameter so, in this case, temp2.
}, temp2);
</code></pre>

<p>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</p>

<pre><code>angular.forEach(temp, function(item) {
    temp2.push(item);
});
</code></pre>

<p>Now there are pros and cons of using the <code>angular.forEach</code> function as opposed to the built in vanilla-flavored <code>for</code> loop.</p>

<p><strong>Pros</strong></p>

<ul>
<li>Easy readability</li>
<li>Easy writability</li>
<li>If available, <code>angular.forEach</code> will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are <em>much</em> slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</li>
</ul>

<p>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action: </p>

<pre><code>angular.forEach(obj1.results, function(result1) {
    angular.forEach(obj2.results, function(result2) {
        if (result1.Value === result2.Value) {
            //do something
        }
    });
});

//exact same with a for loop
for (var i = 0; i &lt; obj1.results.length; i++) {
    for (var j = 0; j &lt; obj2.results.length; j++) {
        if (obj1.results[i].Value === obj2.results[j].Value) {
            //do something
        }
    }
}
</code></pre>

<p>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was <em>very</em> hard to read, and write for that matter.</p>

<p><strong>Cons</strong></p>

<ul>
<li>Efficiency. <code>angular.forEach</code>, and the native <code>forEach</code>, for that matter, are both <em>so much</em> slower than the normal <code>for</code> loop....about <a href="http://jsperf.com/angular-foreach-vs-native-for-loop/3" rel="noreferrer">90% slower</a>. So for large data sets, best to stick to the native <code>for</code> loop.</li>
<li>No break, continue, or return support. <code>continue</code> is actually supported by "<a href="https://github.com/angular/angular.js/issues/263" rel="noreferrer">accident</a>", to continue in an <code>angular.forEach</code> you simple put a <code>return;</code> statement in the function like <code>angular.forEach(array, function(item) { if (someConditionIsTrue) return; });</code> which will cause it to continue out of the function for that iteration. This is also due to the fact that the native <code>forEach</code> does not support break or continue either.</li>
</ul>

<p>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native <code>for</code> loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an <code>angular.forEach</code> in that bad boy.</p>
</div><p class="this-has-helped">This answer has helped 38 people.</p><div class="s-prose js-post-body"><p><strong>As of ECMAScript&nbsp;6:</strong></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>list = [0, 1, 2, 3]
for (let obj of list) {
    console.log(obj)
}</code></pre>
</div>
</div>
</p>

<p>Where <code>of</code> avoids the oddities associated with <code>in</code> and makes it work like the <code>for</code> loop of any other language, and <code>let</code> binds <code>i</code> within the loop as opposed to within the function.</p>

<p>The braces (<code>{}</code>) can be omitted when there is only one command (e.g. in the example above).</p>
</div><p class="this-has-helped">This answer has helped 34 people.</p><div class="s-prose js-post-body"><p>Probably the <code>for(i = 0; i &lt; array.length; i++)</code> loop is not the best choice. Why? If you have this:</p>

<pre><code>var array = new Array();
array[1] = "Hello";
array[7] = "World";
array[11] = "!";
</code></pre>

<p>The method will call from <code>array[0]</code> to <code>array[2]</code>. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</p>

<pre><code>for(var i in array){
    var el = array[i];
    //If you want 'i' to be INT just put parseInt(i)
    //Do something with el
}
</code></pre>

<p>And if you want it to be a function, you can do this:</p>

<pre><code>function foreach(array, call){
    for(var i in array){
        call(array[i]);
    }
}
</code></pre>

<p>If you want to break, a little more logic:</p>

<pre><code>function foreach(array, call){
    for(var i in array){
        if(call(array[i]) == false){
            break;
        }
    }
}
</code></pre>

<p>Example:</p>

<pre><code>foreach(array, function(el){
    if(el != "!"){
        console.log(el);
    } else {
        console.log(el+"!!");
    }
});
</code></pre>

<p>It returns:</p>

<pre><code>//Hello
//World
//!!!
</code></pre>
</div><p class="this-has-helped">This answer has helped 34 people.</p><div class="s-prose js-post-body"><p>There are three implementations of <code>foreach</code> in <a href="http://en.wikipedia.org/wiki/JQuery">jQuery</a> as follows.</p>

<pre><code>var a = [3,2];

$(a).each(function(){console.log(this.valueOf())}); //Method 1
$.each(a, function(){console.log(this.valueOf())}); //Method 2
$.each($(a), function(){console.log(this.valueOf())}); //Method 3
</code></pre>
</div><p class="this-has-helped">This answer has helped 33 people.</p><div class="s-prose js-post-body"><p>An easy solution now would be to use the <a href="https://en.wikipedia.org/wiki/Underscore.js">underscore.js library</a>. It's providing many useful tools, such as <code>each</code> and will automatically delegate the job to the native <code>forEach</code> if available.</p>

<p><a href="http://codepen.io/Micka33/pen/nbyxf">A CodePen example</a> of how it works is:</p>

<pre><code>var arr = ["elemA", "elemB", "elemC"];
_.each(arr, function(elem, index, ar)
{
...
});
</code></pre>

<h3>See also</h3>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Documentation for native <code>Array.prototype.forEach()</code></a>.</li>
<li>In <em><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for_each...in</a></em> (MDN) it is explained that <code>for each (variable in object)</code> is deprecated as the part of ECMA-357 (<a href="https://developer.mozilla.org/en-US/docs/E4X">EAX</a>) standard.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for...of</a> (MDN) describes the next way of iterating using <code>for (variable of object)</code> as the part of the Harmony (ECMAScript&nbsp;6) proposal.</li>
</ul>
</div><p class="this-has-helped">This answer has helped 28 people.</p><div class="s-prose js-post-body"><p>There isn't any <code>for each</code> loop in native <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a>. You can either use libraries to get this functionality (I recommend <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a>), use a simple <code>for</code> in loop.</p>

<pre><code>for (var instance in objects) {
   ...
}
</code></pre>

<p>However, note that there may be reasons to use an even simpler <code>for</code> loop (see Stack Overflow question <em><a href="https://stackoverflow.com/questions/500504">Why is using “for…in” with array iteration such a bad idea?</a></em>)</p>

<pre><code>var instance;
for (var i=0; i &lt; objects.length; i++) {
    var instance = objects[i];
    ...
}
</code></pre>
</div><p class="this-has-helped">This answer has helped 26 people.</p><div class="s-prose js-post-body"><p>ECMAScript&nbsp;5 (the version on JavaScript) to work with Arrays:</p>

<p><strong>forEach</strong> - Iterates through every item in the array and do whatever you need with each item.</p>

<pre><code>['C', 'D', 'E'].forEach(function(element, index) {
  console.log(element + " is #" + (index+1) + " in the musical scale");
});

// Output
// C is the #1 in musical scale
// D is the #2 in musical scale
// E is the #3 in musical scale
</code></pre>

<p>In case, more interested on operation on array using some inbuilt feature.</p>

<p><strong>map</strong> - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</p>

<pre><code>// Let's upper case the items in the array
['bob', 'joe', 'jen'].map(function(elem) {
  return elem.toUpperCase();
});

// Output: ['BOB', 'JOE', 'JEN']
</code></pre>

<p><strong>reduce</strong> - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</p>

<pre><code>[1,2,3,4].reduce(function(previous, current) {
  return previous + current;
});
// Output: 10
// 1st iteration: previous=1, current=2 =&gt; result=3
// 2nd iteration: previous=3, current=3 =&gt; result=6
// 3rd iteration: previous=6, current=4 =&gt; result=10
</code></pre>

<p><strong>every</strong> - Returns true or false if all the elements in the array pass the test in the callback function.</p>

<pre><code>// Check if everybody has 18 years old of more.
var ages = [30, 43, 18, 5];
ages.every(function(elem) {
  return elem &gt;= 18;
});

// Output: false
</code></pre>

<p><strong>filter</strong> - Very similar to every except that filter returns an array with the elements that return true to the given function.</p>

<pre><code>// Finding the even numbers
[1,2,3,4,5,6].filter(function(elem){
  return (elem % 2 == 0)
});

// Output: [2,4,6]
</code></pre>
</div><p class="this-has-helped">This answer has helped 25 people.</p><div class="s-prose js-post-body"><p>There are <strong>a few ways</strong> to loop through an array in JavaScript, as below:</p>

<p><strong>for</strong> - it's <strong>the most common one</strong>. Full block of code for looping <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var languages = ["Java", "JavaScript", "C#", "Python"];
var i, len, text;
for (i = 0, len = languages.length, text = ""; i &lt; len; i++) {
    text += languages[i] + "&lt;br&gt;";
}
document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>while</strong> - loop while a condition is through. It seems to be the fastest loop <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var text = "";
var i = 0;
while (i &lt; 10) {
    text +=  i + ") something&lt;br&gt;";
    i++;
}
document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>do/while</strong> - also loop through a block of code while the condition is true, will run at least one time <br/></p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var text = ""
var i = 0;

do {
    text += i + ") something &lt;br&gt;";
    i++;
}
while (i &lt; 10);

document.getElementById("example").innerHTML = text;</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Functional loops</strong> - <code>forEach</code>, <code>map</code>, <code>filter</code>, also <code>reduce</code> (they loop through the function, but they are used if you need to do something with your array, etc.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// For example, in this case we loop through the number and double them up using the map function
var numbers = [65, 44, 12, 4];
document.getElementById("example").innerHTML = numbers.map(function(num){return num * 2});</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>For more information and examples about functional programming on arrays, look at the blog post <em><a href="http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/" rel="noreferrer">Functional programming in JavaScript: map, filter and reduce</a></em>.</p>
</div><p class="this-has-helped">This answer has helped 24 people.</p><div class="s-prose js-post-body"><p>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</p>

<pre><code>function each( fn, data ) {

    if(typeof fn == 'string')
        eval('fn = function(data, i){' + fn + '}');

    for(var i=0, L=this.length; i &lt; L; i++) 
        fn.call( this[i], data, i );   

    return this;
}

Array.prototype.each = each;  
</code></pre>

<p><strong>Examples of usage:</strong></p>

<p><strong>Example #1</strong></p>

<pre><code>var arr = [];
[1, 2, 3].each( function(a){ a.push( this * this}, arr);
arr = [1, 4, 9]
</code></pre>

<p><strong>Example #2</strong></p>

<pre><code>each.call(document.getElementsByTagName('p'), "this.className = data;",'blue');
</code></pre>

<p>Each p tag gets <code>class="blue"</code></p>

<p><strong>Example #3</strong></p>

<pre><code>each.call(document.getElementsByTagName('p'), 
    "if( i % 2 == 0) this.className = data;",
    'red'
);
</code></pre>

<p>Every other p tag gets <code>class="red"</code>></p>

<p><strong>Example #4</strong></p>

<pre><code>each.call(document.querySelectorAll('p.blue'), 
    function(newClass, i) {
        if( i &lt; 20 )
            this.className = newClass;
    }, 'green'
);
</code></pre>

<p>And finally the first 20 blue p tags are changed to green</p>

<p>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.</p>
</div><p class="this-has-helped">This answer has helped 20 people.</p><div class="s-prose js-post-body"><p>There's no inbuilt ability to break in <code>forEach</code>. To interrupt execution use the <code>Array#some</code> like below:</p>

<pre><code>[1,2,3].some(function(number) {
    return number === 1;
});
</code></pre>

<p>This works because <code>some</code> returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. 
<a href="https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break">Original Answer</a>
see Array prototype for <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17" rel="noreferrer">some</a></p>
</div><p class="this-has-helped">This answer has helped 18 people.</p><div class="s-prose js-post-body"><p>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</p>

<pre><code>var foo = [object,object,object];
for (var i = foo.length, item; item = foo[--i];) {
    console.log(item);
}
</code></pre>

<p><strong>Pros:</strong></p>

<p>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</p>

<p><strong>Cons:</strong></p>

<p>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be "not" optimized to work faster than the original one.</p>
</div><p class="this-has-helped">This answer has helped 12 people.</p><div class="s-prose js-post-body"><p>jQuery way using <code>$.map</code>:</p>

<pre><code>var data = [1, 2, 3, 4, 5, 6, 7];

var newData = $.map(data, function(element) {
    if (element % 2 == 0) {
        return element;
    }
});

// newData = [2, 4, 6];
</code></pre>
</div><p class="this-has-helped">This answer has helped 12 people.</p><div class="s-prose js-post-body"><h3>Use <code>for...of</code> where possible</h3>
<div class="s-table-container">
<table class="s-table">
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>async</code>/<code>await</code> support</th>
<th style="text-align: center;">Skips non-numeric props</th>
<th style="text-align: center;">Immutable index</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow noreferrer"><code>for...of</code></a></td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr>
<td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="nofollow noreferrer"><code>forEach()</code></a></td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr>
<td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...in" rel="nofollow noreferrer"><code>for...in</code></a></td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">✅</td>
</tr>
<tr>
<td style="text-align: center;">Regular <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for" rel="nofollow noreferrer"><code>for</code></a></td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">❌</td>
</tr>
</tbody>
</table>
</div>
<p>As one can see in the table above, <code>for...of</code> should be used wherever it fits. Since it supports async functions, skips non-numeric properties and prevents messing up the loop by accidentally modifying the loop index.</p>
<h4>Syntax</h4>
<pre class="lang-js prettyprint-override"><code>const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (const num of nums) {
  /* Do something with num */
}
</code></pre>
<p>See <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow noreferrer"><code>for...of</code></a> reference for more examples, link to specification and difference between <code>for...of</code> and <code>for...in</code>. Or maybe check this <a href="https://masteringjs.io/tutorials/fundamentals/array-iterate" rel="nofollow noreferrer">tutorial</a> for some explanation on how they differ.</p>
</div><p class="this-has-helped">This answer has helped 11 people.</p><div class="s-prose js-post-body"><h2>Summary:</h2>

<p>When iterating over an array, we often want to accomplish one of the following goals:</p>

<ol>
<li><p>We want to iterate over the array and create a new array:</p>

<p><code>Array.prototype.map</code> <br><br></p></li>
<li><p>We want to iterate over the array and don't create a new array:</p>

<p><code>Array.prototype.forEach</code> <br><br>
<code>for..of</code> <strong>loop</strong></p></li>
</ol>

<p>In JavaScript, there are many ways of accomplishing both of these goals. However, some are more convenient than others. Below you can find some commonly used methods (the most convenient IMO) to accomplish array iteration in JavaScript.</p>

<h2>Creating new array: <code>Map</code></h2>

<p><code>map()</code> is a function located on <code>Array.prototype</code> which can transform every element of an array and then returns a <strong>new</strong> array. <code>map()</code> takes as an argument a callback function and works in the following manner:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

let newArr = arr.map((element, index, array) =&gt; {
  return element * 2;
})

console.log(arr);
console.log(newArr);</code></pre>
</div>
</div>
</p>

<p>The callback which we have passed into <code>map()</code> as an argument gets executed for every element. Then an array gets returned which has the same length as the original array. In this new array element is transformed by the callback function passed in as an argument to <code>map()</code>.</p>

<p>The distinct difference between <code>map</code> and another loop mechanism like <code>forEach</code> and a <code>for..of</code> loop is that <strong><code>map</code> returns a new array and leaves the old array intact</strong> (except if you explicitly manipulate it with thinks like <code>splice</code>).</p>

<p>Also, note that the <code>map</code> function's callback provides the index number of the current iteration as a second argument. Furthermore, does the third argument provide the array on which <code>map</code> was called? Sometimes these properties can be very useful.</p>

<h2>Loop using <code>forEach</code></h2>

<p><code>forEach</code> is a function which is located on <code>Array.prototype</code> which takes a callback function as an argument. It then executes this callback function for every element in the array. In contrast to the <code>map()</code> function, the forEach function returns nothing (<code>undefined</code>). For example:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.forEach((element, index, array) =&gt; {

  console.log(element * 2);

  if (index === 4) {
    console.log(array)
  }
  // index, and oldArray are provided as 2nd and 3th argument by the callback

})

console.log(arr);</code></pre>
</div>
</div>
</p>

<p>Just like the <code>map</code> function, the <code>forEach</code> callback provides the index number of the current iteration as a second argument. Also, does the third argument provide the array on which <code>forEach</code> was called?</p>

<h2>Loop through elements using <code>for..of</code></h2>

<p>The <code>for..of</code> loop loops through every element of an array (or any other iterable object). It works in the following manner:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

for(let element of arr) {
  console.log(element * 2);
}</code></pre>
</div>
</div>
</p>

<p>In the above example, <code>element</code> stands for an array element and <code>arr</code> is the array which we want to loop. Note that the name <code>element</code> is arbitrary, and we could have picked any other name like 'el' or something more declarative when this is applicable.</p>

<p>Don't confuse the <code>for..in</code> loop with the <code>for..of</code> loop. <code>for..in</code> will loop through all enumerable properties of the array whereas the <code>for..of</code> loop will only loop through the array elements. For example:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.foo = 'foo';

for(let element of arr) {
  console.log(element);
}

for(let element in arr) {
  console.log(element);
}</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 11 people.</p><div class="s-prose js-post-body"><p><strong>Using loops with ECMAScript 6  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noreferrer">destructuring</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread operator</a></strong></p>
<p>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript 6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</p>
<blockquote>
<p>The following examples will use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><code>for...of</code></a> statement and the <a href="https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>.forEach</code></a> method.</p>
<p><strong>Examples 6, 7, and 8</strong> can be used with any functional loops like <code>.map</code>, <code>.filter</code>, <code>.reduce</code>, <code>.sort</code>, <code>.every</code>, <code>.some</code>. For more information about these methods, check out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">Array Object</a>.</p>
</blockquote>
<p><strong>Example 1:</strong> Normal <code>for...of</code> loop - no tricks here.</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrSimple = ['a', 'b', 'c'];

for (let letter of arrSimple) {
  console.log(letter);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 2:</strong> Split words to characters</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrFruits = ['apple', 'orange', 'banana'];

for (let [firstLetter, ...restOfTheWord] of arrFruits) {
  // Create a shallow copy using the spread operator
  let [lastLetter] = [...restOfTheWord].reverse();
  console.log(firstLetter, lastLetter, restOfTheWord);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 3:</strong> Looping with a <code>key</code> and <code>value</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>// let arrSimple = ['a', 'b', 'c'];

// Instead of keeping an index in `i` as per example `for(let i = 0 ; i&lt;arrSimple.length;i++)`
// this example will use a multi-dimensional array of the following format type:
// `arrWithIndex: [number, string][]`

let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Same thing can be achieved using `.map` method
// let arrWithIndex = arrSimple.map((i, idx) =&gt; [idx, i]);

// Same thing can be achieved using `Object.entries`
// NOTE: `Object.entries` method doesn't work on Internet Explorer  unless it's polyfilled
// let arrWithIndex = Object.entries(arrSimple);

for (let [key, value] of arrWithIndex) {
  console.log(key, value);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 4:</strong> Get object properties inline</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];

for (let { name, age: aliasForAge } of arrWithObjects) {
  console.log(name, aliasForAge);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 5:</strong> Get deep object properties of what you need</p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

for (let { name, tags: [firstItemFromTags, ...restOfTags] } of arrWithObjectsWithArr) {
  console.log(name, firstItemFromTags, restOfTags);
}</code></pre>
</div>
</div>
</p>
<p><strong>Example 6:</strong> Is <strong>Example 3</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Not to be confused here, `forEachIndex` is the real index
// `mappedIndex` was created by "another user", so you can't really trust it

arrWithIndex.forEach(([mappedIndex, item], forEachIndex) =&gt; {
  console.log(forEachIndex, mappedIndex, item);
});</code></pre>
</div>
</div>
</p>
<p><strong>Example 7:</strong> Is <strong>Example 4</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];
// NOTE: Destructuring objects while using shorthand functions
// are required to be surrounded by parentheses
arrWithObjects.forEach( ({ name, age: aliasForAge }) =&gt; {
  console.log(name, aliasForAge)
});</code></pre>
</div>
</div>
</p>
<p><strong>Example 8:</strong> Is <strong>Example 5</strong> used with <code>.forEach</code></p>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

arrWithObjectsWithArr.forEach(({
  name,
  tags: [firstItemFromTags, ...restOfTags]
}) =&gt; {
  console.log(name, firstItemFromTags, restOfTags);
});</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 10 people.</p><div class="s-prose js-post-body"><h2>Performance</h2>

<p>Today (2019-12-18) I perform test on my <a href="https://en.wikipedia.org/wiki/MacOS_High_Sierra" rel="noreferrer">macOS v10.13.6</a> (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em> which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</p>

<ul>
<li><p>It looks like the traditional <code>for i</code> (<strong>Aa</strong>) is a good choice to write fast code on all browsers.</p></li>
<li><p>The other solutions, like <code>for-of</code> (<strong>Ad</strong>), all in group <strong>C.</strong>... are usually 2 - 10 (and more) times slower than <strong>Aa</strong>, but for small arrays it is ok to use it - for the sake of increase code clarity.</p></li>
<li><p>The loops with array length cached in <code>n</code> (<strong>Ab, Bb, Be</strong>) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (<strong>Aa, Ba, Bd</strong>) are about ~1%, so it looks like introduce <code>n</code> is a <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em>.</p></li>
<li><p>The <code>i--</code> like solutions where the loop starts from the last array element (<strong>Ac, Bc</strong>) are usually ~30% slower than forward solutions - probably the reason is the way of <a href="https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus">CPU memory cache working</a> - forward memory reading is more optimal for CPU caching). <strong>Is recommended to NOT USE such solutions.</strong></p></li>
</ul>

<h2>Details</h2>

<p>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</p>

<ul>
<li><strong>A</strong> - <code>for</code> tests</li>
<li><strong>B</strong> - <code>while</code> tests</li>
<li><strong>C</strong> - other/alternative methods</li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//let arr = Array.from(Array(1000000), (x, i) =&gt; i%10);

function Aa(a, s=0) {
  for(let i=0; i&lt;a.length; i++) {
    s += a[i];
  }
  console.log('Aa=', s);
}

function Ab(a, s=0) {
  let n = a.length;
  for(let i=0; i&lt;n; i++) {
    s += a[i];
  }
  console.log('Ab=', s);
}

function Ac(a, s=0) {
  for(let i=a.length; i--;) {
    s += a[i];
  }
  console.log('Ac=', s);
}

function Ad(a, s=0) {
  for(let x of a) {
    s += x;
  }
  console.log('Ad=', s);
}

function Ae(a, s=0) {
  for(let i in a) if (a.hasOwnProperty(i)) {
    s += a[i];
  }
  console.log('Ae=', s);
}

function Ba(a, s=0) {
  let i = -1;
  while(++i &lt; a.length) {
    s+= a[i];
  }
  console.log('Ba=', s);
}

function Bb(a, s=0) {
  let i = -1;
  let n = a.length;
  while(++i &lt; n) {
    s+= a[i];
  }
  console.log('Bb=', s);
}

function Bc(a, s=0) {
  let i = a.length;
  while(i--) {
    s += a[i];
  }
  console.log('Bc=', s);
}

function Bd(a, s=0) {
  let i = 0;
  do {
    s+= a[i]
  } while (++i &lt; a.length);
  console.log('Bd=', s);
}

function Be(a, s=0) {
  let i = 0;
  let n = a.length;
  do {
    s += a[i]
  } while (++i &lt; n);
  console.log('Be=', s);
}

function Bf(a, s=0) {
  const it = a.values(); 
  let e;
  while (!(e = it.next()).done) { 
    s+= e.value; 
  }
  console.log('Bf=', s);
}

function Ca(a, s=0) {
  a.map(x =&gt; { s+=x });
  console.log('Ca=', s);
}

function Cb(a, s=0) {
  a.forEach(x =&gt; { s+=x });
  console.log('Cb=', s);
}

function Cc(a, s=0) {
  a.every(x =&gt; (s += x, 1));
  console.log('Cc=', s);
}

function Cd(a, s=0) {
  a.filter(x =&gt; { s+=x });
  console.log('Cd=',s);
}

function Ce(a, s=0) {
  a.reduce((z, c) =&gt; { s+=c }, 0);
  console.log('Ce=', s);
}

function Cf(a, s=0) {
  a.reduceRight((z, c) =&gt; { s += c }, 0);
  console.log('Cf=', s);
}

function Cg(a, s=0) {
  a.some(x =&gt; { s += x } );
  console.log('Cg=', s);
}

function Ch(a, s=0) {
  Array.from(a, x=&gt; s += x);
  console.log('Cc=', s);
}


Aa(arr);
Ab(arr);
Ac(arr);
Ad(arr);
Ae(arr);

Ba(arr);
Bb(arr);
Bc(arr);
Bd(arr);
Be(arr);
Bf(arr);

Ca(arr);
Cb(arr);
Cc(arr);
Cd(arr);
Ce(arr);
Cf(arr);
Cg(arr);
Ch(arr);</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p style="color: red"&gt;This snippets only PRESENTS code used for benchmark - it not perform test itself&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Cross browser results</strong></p>

<p>Results for all tested browsers</p>

<p><a href="https://i.stack.imgur.com/bSXp2.png" rel="noreferrer"><img src="https://i.stack.imgur.com/bSXp2.png" alt="Enter image description here"></a>browsers**</p>

<p><strong>Array with 10 elements</strong></p>

<p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/pxk4bicjru" rel="noreferrer">here</a>.</p>

<p><a href="https://i.stack.imgur.com/VuCMw.png" rel="noreferrer"><img src="https://i.stack.imgur.com/VuCMw.png" alt="Enter image description here"></a></p>

<p><strong>Array with 1,000,000 elements</strong></p>

<p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/9uk4bj4svg" rel="noreferrer">here</a></p>

<p><a href="https://i.stack.imgur.com/8JQf6.png" rel="noreferrer"><img src="https://i.stack.imgur.com/8JQf6.png" alt="Enter image description here"></a></p>
</div><p class="this-has-helped">This answer has helped 9 people.</p><div class="s-prose js-post-body"><p>A way closest to your idea would be to use <code>Array.forEach()</code> which accepts a closure function which will be executed for each element of the array.</p>

<pre><code>myArray.forEach(
  (item) =&gt; {
    // Do something
    console.log(item);
  }
);
</code></pre>

<p>Another viable way would be to use <code>Array.map()</code> which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</p>

<pre><code>var myArray = [1, 2, 3];
myArray = myArray.map(
  (item) =&gt; {
    return item + 1;
  }
);

console.log(myArray); // [2, 3, 4]
</code></pre>
</div><p class="this-has-helped">This answer has helped 9 people.</p><div class="s-prose js-post-body"><p>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</p>

<blockquote>
  <p><strong>for loops</strong></p>
</blockquote>

<pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(i);
}

// Output: 0,1,2,3,4
</code></pre>

<blockquote>
  <p><strong>for...in loops</strong></p>
</blockquote>

<pre><code>let obj = {"a":1, "b":2}

for(let k in obj){
  console.log(k)
}

// Output: a,b
</code></pre>

<blockquote>
  <p><strong>Array.forEach()</strong></p>
</blockquote>

<pre><code>let array = [1,2,3,4]

array.forEach((x) =&gt; {
  console.log(x);
})

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>for...of loops</strong></p>
</blockquote>

<pre><code>let array = [1,2,3,4]

for(let x of array){
  console.log(x);
}

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>while loops</strong></p>
</blockquote>

<pre><code>let x = 0

while(x &lt; 5){
  console.log(x)
  x++
}

// Output: 1,2,3,4
</code></pre>

<blockquote>
  <p><strong>do...while loops</strong></p>
</blockquote>

<pre><code>let x = 0

do{
  console.log(x)
  x++
}while(x &lt; 5)

// Output: 1,2,3,4
</code></pre>
</div><p class="this-has-helped">This answer has helped 8 people.</p><div class="s-prose js-post-body"><p>The lambda syntax doesn't usually work in Internet&nbsp;Explorer&nbsp;10  or below.</p>

<p>I usually use the</p>

<pre><code>[].forEach.call(arrayName,function(value,index){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>

<p>If you are a jQuery <em>fan</em> and already have a jQuery file running, you should reverse the positions of the index and value parameters</p>

<pre><code>$("#ul&gt;li").each(function(**index, value**){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>
</div><p class="this-has-helped">This answer has helped 8 people.</p><div class="s-prose js-post-body"><p>You can call forEach like this:</p>

<p><code>forEach</code> will iterate over the array you provide and for each iteration it will have <code>element</code> which holds the value of that iteration. If you need index you can get the current index by passing the <code>i</code> as the second parameter in the callback function for forEach. </p>

<p>Foreach is basically a High Order Function, Which takes another function as its parameter. </p>

<pre><code>let theArray= [1,3,2];

theArray.forEach((element) =&gt; {
  // Use the element of the array
  console.log(element)
}
</code></pre>

<p>Output:</p>

<pre><code>1
3
2
</code></pre>

<p>You can also iterate over an array like this:</p>

<pre><code>for (let i=0; i&lt;theArray.length; i++) {
  console.log(i); // i will have the value of each index
}
</code></pre>
</div><p class="this-has-helped">This answer has helped 7 people.</p><div class="s-prose js-post-body"><p>If you want to use <code>forEach()</code>, it will look like - </p>

<pre><code>theArray.forEach ( element =&gt; {
    console.log(element);
});
</code></pre>

<p>If you want to use <code>for()</code>, it will look like -   </p>

<pre><code>for(let idx = 0; idx &lt; theArray.length; idx++){
    let element = theArray[idx];
    console.log(element);
}
</code></pre>
</div><p class="this-has-helped">This answer has helped 7 people.</p><div class="s-prose js-post-body"><p>If you want to loop through an array of objects with the arrow function:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [{name:'john', age:50}, {name:'clark', age:19}, {name:'mohan', age:26}];

arr.forEach((person)=&gt;{
  console.log('I am ' + person.name + ' and I am ' + person.age + ' old');
})</code></pre>
</div>
</div>
</p>
</div><p class="this-has-helped">This answer has helped 5 people.</p><div class="s-prose js-post-body"><p>If you have a massive array you should use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><strong><code>iterators</code></strong></a> to gain some efficiency. Iterators are a property of certain JavaScript collections (like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noreferrer"><code>Map</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noreferrer"><code>Set</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noreferrer"><code>String</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer"><code>Array</code></a>). Even, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><strong><code>for..of</code></strong></a> uses <strong><code>iterator</code></strong> under-the-hood.</p>

<p>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.             </p>

<p>You access the current item by calling the iterator’s <code>next</code> method. The next method will return the <strong><code>value</code></strong> of the current item and a <strong><code>boolean</code></strong> to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.               </p>

<p>Transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values" rel="noreferrer"><code>values()</code></a> method like this:               </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>    const myArr = [2,3,4]

let it = myArr.values();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
</div>
</div>
</p>

<p>You can also transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" rel="noreferrer"><code>Symbol.iterator</code></a> like this:         </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const myArr = [2,3,4]

let it = myArr[Symbol.iterator]();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
</div>
</div>
</p>

<p>You can also transform your regular <code>array</code> to an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><code>iterator</code></a> like this:          </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let myArr = [8, 10, 12];

function makeIterator(array) {
    var nextIndex = 0;
    
    return {
       next: function() {
           return nextIndex &lt; array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    };
};

var it = makeIterator(myArr);

console.log(it.next().value);   // {value: 8, done: false}
console.log(it.next().value);   // {value: 10, done: false}
console.log(it.next().value);   // {value: 12, done: false}
console.log(it.next().value);   // {value: undefined, done: true}</code></pre>
</div>
</div>
</p>

<p><strong>NOTE</strong>:                </p>

<ul>
<li>Iterators are exhaustible in nature. </li>
<li>Objects are not <code>iterable</code> by default. Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code></a> in that case because instead of values it works with keys.</li>
</ul>

<p>You can read more about <code>iteration protocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">here</a>.  </p>
</div><p class="this-has-helped">This answer has helped 5 people.</p><div class="s-prose js-post-body"><p>You can use:</p>

<ol>
<li><p>ForEach</p>

<pre><code>theArray.forEach(function (array, index) {
    console.log(index);
    console.log(array);
});
</code></pre></li>
<li><p>for</p>

<pre><code>for(var i=0; i&lt;theArray.length; i++) {
    console.log(i)
}
</code></pre></li>
<li><p>map</p>

<pre><code>theArray.map(x =&gt; console.log(x));
</code></pre></li>
<li><p>map</p>

<pre><code>theArray.filter(x =&gt; console.log(x));
</code></pre></li>
</ol>

<p>And there are many others for iteration.</p>
</div></body></html>