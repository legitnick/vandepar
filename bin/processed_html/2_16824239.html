<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><head><link href="../../src/css/general.css" rel="stylesheet" /></head> itemprop="text">
<p>Here's a possible implementation relying on C++11 features. It correctly detects the function even if it's inherited (unlike the solution in the accepted answer, as Mike Kinghan observes in <a href="https://stackoverflow.com/a/10707822/947836">his answer</a>).</p>

<p>The function this snippet tests for is called <code>serialize</code>:</p>

<pre><code>#include &lt;type_traits&gt;

// Primary template with a static assertion
// for a meaningful error message
// if it ever gets instantiated.
// We could leave it undefined if we didn't care.

template&lt;typename, typename T&gt;
struct has_serialize {
    static_assert(
        std::integral_constant&lt;T, false&gt;::value,
        "Second template parameter needs to be of function type.");
};

// specialization that does the checking

template&lt;typename C, typename Ret, typename... Args&gt;
struct has_serialize&lt;C, Ret(Args...)&gt; {
private:
    template&lt;typename T&gt;
    static constexpr auto check(T*)
    -&gt; typename
        std::is_same&lt;
            decltype( std::declval&lt;T&gt;().serialize( std::declval&lt;Args&gt;()... ) ),
            Ret    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        &gt;::type;  // attempt to call it and see if the return type is correct

    template&lt;typename&gt;
    static constexpr std::false_type check(...);

    typedef decltype(check&lt;C&gt;(0)) type;

public:
    static constexpr bool value = type::value;
};
</code></pre>

<p>Usage:</p>

<pre><code>struct X {
     int serialize(const std::string&amp;) { return 42; } 
};

struct Y : X {};

std::cout &lt;&lt; has_serialize&lt;Y, int(const std::string&amp;)&gt;::value; // will print 1
</code></pre>
    </div><div </body></html>