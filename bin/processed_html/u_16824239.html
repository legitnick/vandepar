<!DOCTYPE html><html lang="en"><head><style>@import url("https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;1,200;1,300&family=Work+Sans:wght@400;500&display=swap");</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><head><link href="../../src/css/general.css" rel="stylesheet" /></head><a href="/questions/87372/check-if-a-class-has-a-member-function-of-a-given-signature" class="question-hyperlink">Check if a class has a member function of a given signature</a><div class="s-prose js-post-body" itemprop="text">
                
<p>I'm asking for a template trick to detect if a class has a specific member function of a given signature.</p>

<p>The problem is similar to the one cited here
<a href="http://www.gotw.ca/gotw/071.htm" rel="noreferrer">http://www.gotw.ca/gotw/071.htm</a>
but not the same: in the item of Sutter's book he answered to the question that a class C MUST PROVIDE  a member function with a particular signature, else the program won't compile. In my problem I need to do something if a class has that function, else do "something else". </p>

<p>A similar problem was faced by boost::serialization but I don't like the solution they adopted: a template function that invokes by default a free function (that you have to define) with a particular signature unless you define a particular member function (in their case "serialize" that takes 2 parameters of a given type) with a particular signature, else a compile error will happens. That is to implement both intrusive and non-intrusive serialization. </p>

<p>I don't like that solution for two reasons:</p>

<ol>
<li>To be non intrusive you must override the global "serialize" function that is in boost::serialization namespace, so you have IN YOUR CLIENT CODE to open namespace boost and namespace serialization!</li>
<li>The stack to resolve that
mess was 10 to 12 function invocations.</li>
</ol>

<p>I need to define a custom behavior for classes that has not that member function, and my entities are inside different namespaces (and I don't want to override a global function defined in one namespace while I'm in another one)</p>

<p>Can you give me a hint to solve this puzzle?</p>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>Here's a possible implementation relying on C++11 features. It correctly detects the function even if it's inherited (unlike the solution in the accepted answer, as Mike Kinghan observes in <a href="https://stackoverflow.com/a/10707822/947836">his answer</a>).</p>

<p>The function this snippet tests for is called <code>serialize</code>:</p>

<pre><code>#include &lt;type_traits&gt;

// Primary template with a static assertion
// for a meaningful error message
// if it ever gets instantiated.
// We could leave it undefined if we didn't care.

template&lt;typename, typename T&gt;
struct has_serialize {
    static_assert(
        std::integral_constant&lt;T, false&gt;::value,
        "Second template parameter needs to be of function type.");
};

// specialization that does the checking

template&lt;typename C, typename Ret, typename... Args&gt;
struct has_serialize&lt;C, Ret(Args...)&gt; {
private:
    template&lt;typename T&gt;
    static constexpr auto check(T*)
    -&gt; typename
        std::is_same&lt;
            decltype( std::declval&lt;T&gt;().serialize( std::declval&lt;Args&gt;()... ) ),
            Ret    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        &gt;::type;  // attempt to call it and see if the return type is correct

    template&lt;typename&gt;
    static constexpr std::false_type check(...);

    typedef decltype(check&lt;C&gt;(0)) type;

public:
    static constexpr bool value = type::value;
};
</code></pre>

<p>Usage:</p>

<pre><code>struct X {
     int serialize(const std::string&amp;) { return 42; } 
};

struct Y : X {};

std::cout &lt;&lt; has_serialize&lt;Y, int(const std::string&amp;)&gt;::value; // will print 1
</code></pre>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>I'm not sure if I understand you correctly, but you may exploit SFINAE to detect function presence at compile-time. Example from my code (tests if class has member function size_t used_memory() const).</p>

<pre><code>template&lt;typename T&gt;
struct HasUsedMemoryMethod
{
    template&lt;typename U, size_t (U::*)() const&gt; struct SFINAE {};
    template&lt;typename U&gt; static char Test(SFINAE&lt;U, &amp;U::used_memory&gt;*);
    template&lt;typename U&gt; static int Test(...);
    static const bool Has = sizeof(Test&lt;T&gt;(0)) == sizeof(char);
};

template&lt;typename TMap&gt;
void ReportMemUsage(const TMap&amp; m, std::true_type)
{
        // We may call used_memory() on m here.
}
template&lt;typename TMap&gt;
void ReportMemUsage(const TMap&amp;, std::false_type)
{
}
template&lt;typename TMap&gt;
void ReportMemUsage(const TMap&amp; m)
{
    ReportMemUsage(m, 
        std::integral_constant&lt;bool, HasUsedMemoryMethod&lt;TMap&gt;::Has&gt;());
}
</code></pre>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>The accepted answer to this question of compiletime member-function
introspection, although it is justly popular, has a snag which can be observed
in the following program:</p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;

/*  Here we apply the accepted answer's technique to probe for the
    the existence of `E T::operator*() const`
*/
template&lt;typename T, typename E&gt;
struct has_const_reference_op
{
    template&lt;typename U, E (U::*)() const&gt; struct SFINAE {};
    template&lt;typename U&gt; static char Test(SFINAE&lt;U, &amp;U::operator*&gt;*);
    template&lt;typename U&gt; static int Test(...);
    static const bool value = sizeof(Test&lt;T&gt;(0)) == sizeof(char);
};

using namespace std;

/* Here we test the `std::` smart pointer templates, including the
    deprecated `auto_ptr&lt;T&gt;`, to determine in each case whether
    T = (the template instantiated for `int`) provides 
    `int &amp; T::operator*() const` - which all of them in fact do.
*/ 
int main(void)
{
    cout &lt;&lt; has_const_reference_op&lt;auto_ptr&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;shared_ptr&lt;int&gt;,int &amp;&gt;::value &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Built with GCC 4.6.3, the program outputs <code>110</code> - informing us that 
<code>T = std::shared_ptr&lt;int&gt;</code> does <em>not</em> provide <code>int &amp; T::operator*() const</code>.</p>

<p>If you are not already wise to this gotcha, then a look at of the definition of
<code>std::shared_ptr&lt;T&gt;</code> in the header <code>&lt;memory&gt;</code> will shed light. In that
implementation, <code>std::shared_ptr&lt;T&gt;</code> is derived from a base class
from which it inherits <code>operator*() const</code>. So the template instantiation
<code>SFINAE&lt;U, &amp;U::operator*&gt;</code> that constitutes "finding" the operator for
<code>U = std::shared_ptr&lt;T&gt;</code> will not happen, because <code>std::shared_ptr&lt;T&gt;</code> has no
<code>operator*()</code> in its own right and template instantiation does not
"do inheritance".</p>

<p>This snag does not affect the well-known SFINAE approach, using "The sizeof() Trick",
for detecting merely whether <code>T</code> has some member function <code>mf</code> (see e.g.
<a href="https://stackoverflow.com/a/257382/1362568">this answer</a> and comments). But
establishing that <code>T::mf</code> exists is often (usually?) not good enough: you may
also need to establish that it has a desired signature. That is where the
illustrated technique scores. The pointerized variant of the desired signature
is inscribed in a parameter of a template type that must be satisfied by
<code>&amp;T::mf</code> for the SFINAE probe to succeed. But this template instantiating
technique gives the wrong answer when <code>T::mf</code> is inherited.</p>

<p>A safe SFINAE technique for compiletime introspection of <code>T::mf</code> must avoid the
use of <code>&amp;T::mf</code> within a template argument to instantiate a type upon which SFINAE
function template resolution depends. Instead, SFINAE template function
resolution can depend only upon exactly pertinent type declarations used
as argument types of the overloaded SFINAE probe function.</p>

<p>By way of an answer to the question that abides by this constraint I'll
illustrate for compiletime detection of <code>E T::operator*() const</code>, for
arbitrary <code>T</code> and <code>E</code>. The same pattern will apply <em>mutatis mutandis</em>
to probe for any other member method signature.</p>

<pre><code>#include &lt;type_traits&gt;

/*! The template `has_const_reference_op&lt;T,E&gt;` exports a
    boolean constant `value that is true iff `T` provides
    `E T::operator*() const`
*/ 
template&lt; typename T, typename E&gt;
struct has_const_reference_op
{
    /* SFINAE operator-has-correct-sig :) */
    template&lt;typename A&gt;
    static std::true_type test(E (A::*)() const) {
        return std::true_type();
    }

    /* SFINAE operator-exists :) */
    template &lt;typename A&gt; 
    static decltype(test(&amp;A::operator*)) 
    test(decltype(&amp;A::operator*),void *) {
        /* Operator exists. What about sig? */
        typedef decltype(test(&amp;A::operator*)) return_type; 
        return return_type();
    }

    /* SFINAE game over :( */
    template&lt;typename A&gt;
    static std::false_type test(...) {
        return std::false_type(); 
    }

    /* This will be either `std::true_type` or `std::false_type` */
    typedef decltype(test&lt;T&gt;(0,0)) type;

    static const bool value = type::value; /* Which is it? */
};
</code></pre>

<p>In this solution, the overloaded SFINAE probe function <code>test()</code> is "invoked
recursively". (Of course it isn't actually invoked at all; it merely has
the return types of hypothetical invocations resolved by the compiler.)</p>

<p>We need to probe for at least one and at most two points of information:</p>

<ul>
<li>Does <code>T::operator*()</code> exist at all? If not, we're done.</li>
<li>Given that <code>T::operator*()</code> exists, is its signature 
<code>E T::operator*() const</code>?</li>
</ul>

<p>We get the answers by evaluating the return type of a single call
to <code>test(0,0)</code>. That's done by:</p>

<pre><code>    typedef decltype(test&lt;T&gt;(0,0)) type;
</code></pre>

<p>This call might be resolved to the <code>/* SFINAE operator-exists :) */</code> overload
of <code>test()</code>, or it might resolve to the <code>/* SFINAE game over :( */</code> overload.
It can't resolve to the <code>/* SFINAE operator-has-correct-sig :) */</code> overload,
because that one expects just one argument and we are passing two.</p>

<p>Why are we passing two? Simply to force the resolution to exclude 
<code>/* SFINAE operator-has-correct-sig :) */</code>. The second argument has no other signifance.</p>

<p>This call to <code>test(0,0)</code> will resolve to <code>/* SFINAE operator-exists :) */</code> just
in case the first argument 0 satifies the first parameter type of that overload,
which is <code>decltype(&amp;A::operator*)</code>, with <code>A = T</code>. 0 will satisfy that type
just in case <code>T::operator*</code> exists.</p>

<p>Let's suppose the compiler say's Yes to that. Then it's going with
<code>/* SFINAE operator-exists :) */</code> and it needs to determine the return type of
the function call, which in that case is <code>decltype(test(&amp;A::operator*))</code> -
the return type of yet another call to <code>test()</code>.</p>

<p>This time, we're passing just one argument, <code>&amp;A::operator*</code>, which we now
know exists, or we wouldn't be here. A call to <code>test(&amp;A::operator*)</code> might
resolve either to <code>/* SFINAE operator-has-correct-sig :) */</code> or again to
might resolve to <code>/* SFINAE game over :( */</code>. The call will match 
<code>/* SFINAE operator-has-correct-sig :) */</code> just in case <code>&amp;A::operator*</code> satisfies
the single parameter type of that overload, which is <code>E (A::*)() const</code>,
with <code>A = T</code>.</p>

<p>The compiler will say Yes here if <code>T::operator*</code> has that desired signature,
and then again has to evaluate the return type of the overload. No more
"recursions" now: it is <code>std::true_type</code>.</p>

<p>If the compiler does not choose <code>/* SFINAE operator-exists :) */</code> for the
call <code>test(0,0)</code> or does not choose <code>/* SFINAE operator-has-correct-sig :) */</code>
for the call <code>test(&amp;A::operator*)</code>, then in either case it goes with
<code>/* SFINAE game over :( */</code> and the final return type is <code>std::false_type</code>.</p>

<p>Here is a test program that shows the template producing the expected
answers in varied sample of cases (GCC 4.6.3 again).</p>

<pre><code>// To test
struct empty{};

// To test 
struct int_ref
{
    int &amp; operator*() const {
        return *_pint;
    }
    int &amp; foo() const {
        return *_pint;
    }
    int * _pint;
};

// To test 
struct sub_int_ref : int_ref{};

// To test 
template&lt;typename E&gt;
struct ee_ref
{
    E &amp; operator*() {
        return *_pe;
    }
    E &amp; foo() const {
        return *_pe;
    }
    E * _pe;
};

// To test 
struct sub_ee_ref : ee_ref&lt;char&gt;{};

using namespace std;

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

int main(void)
{
    cout &lt;&lt; "Expect Yes" &lt;&lt; endl;
    cout &lt;&lt; has_const_reference_op&lt;auto_ptr&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;shared_ptr&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;std::vector&lt;int&gt;::iterator,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;std::vector&lt;int&gt;::const_iterator,
            int const &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;int_ref,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;sub_int_ref,int &amp;&gt;::value  &lt;&lt; endl;
    cout &lt;&lt; "Expect No" &lt;&lt; endl;
    cout &lt;&lt; has_const_reference_op&lt;int *,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;int&gt;,char &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;int&gt;,int const &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;int&gt;,int&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;unique_ptr&lt;long&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;int,int&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;std::vector&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;ee_ref&lt;int&gt;,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;sub_ee_ref,int &amp;&gt;::value;
    cout &lt;&lt; has_const_reference_op&lt;empty,int &amp;&gt;::value  &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Are there new flaws in this idea? Can it be made more generic without once again
falling foul of the snag it avoids?</p>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>Here are some usage snippets:
*The guts for all this are farther down</p>

<p><strong>Check for member <code>x</code> in a given class.  Could be var, func, class, union, or enum:</strong></p>

<pre><code>CREATE_MEMBER_CHECK(x);
bool has_x = has_member_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member function <code>void x()</code>:</strong></p>

<pre><code>//Func signature MUST have T as template variable here... simpler this way :\
CREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);
bool has_func_sig_void__x = has_member_func_void__x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member variable <code>x</code>:</strong></p>

<pre><code>CREATE_MEMBER_VAR_CHECK(x);
bool has_var_x = has_member_var_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member class <code>x</code>:</strong></p>

<pre><code>CREATE_MEMBER_CLASS_CHECK(x);
bool has_class_x = has_member_class_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member union <code>x</code>:</strong></p>

<pre><code>CREATE_MEMBER_UNION_CHECK(x);
bool has_union_x = has_member_union_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member enum <code>x</code>:</strong></p>

<pre><code>CREATE_MEMBER_ENUM_CHECK(x);
bool has_enum_x = has_member_enum_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for any member function <code>x</code> regardless of signature:</strong></p>

<pre><code>CREATE_MEMBER_CHECK(x);
CREATE_MEMBER_VAR_CHECK(x);
CREATE_MEMBER_CLASS_CHECK(x);
CREATE_MEMBER_UNION_CHECK(x);
CREATE_MEMBER_ENUM_CHECK(x);
CREATE_MEMBER_FUNC_CHECK(x);
bool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p>OR</p>

<pre><code>CREATE_MEMBER_CHECKS(x);  //Just stamps out the same macro calls as above.
bool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Details and core:</strong></p>

<pre><code>/*
    - Multiple inheritance forces ambiguity of member names.
    - SFINAE is used to make aliases to member names.
    - Expression SFINAE is used in just one generic has_member that can accept
      any alias we pass it.
*/

//Variadic to force ambiguity of class members.  C++11 and up.
template &lt;typename... Args&gt; struct ambiguate : public Args... {};

//Non-variadic version of the line above.
//template &lt;typename A, typename B&gt; struct ambiguate : public A, public B {};

template&lt;typename A, typename = void&gt;
struct got_type : std::false_type {};

template&lt;typename A&gt;
struct got_type&lt;A&gt; : std::true_type {
    typedef A type;
};

template&lt;typename T, T&gt;
struct sig_check : std::true_type {};

template&lt;typename Alias, typename AmbiguitySeed&gt;
struct has_member {
    template&lt;typename C&gt; static char ((&amp;f(decltype(&amp;C::value))))[1];
    template&lt;typename C&gt; static char ((&amp;f(...)))[2];

    //Make sure the member name is consistently spelled the same.
    static_assert(
        (sizeof(f&lt;AmbiguitySeed&gt;(0)) == 1)
        , "Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified."
    );

    static bool const value = sizeof(f&lt;Alias&gt;(0)) == 2;
};
</code></pre>

<p><em><strong>Macros (El Diablo!):</strong></em></p>

<p><strong>CREATE_MEMBER_CHECK:</strong></p>

<pre><code>//Check for any member with given name, whether var, func, class, union, enum.
#define CREATE_MEMBER_CHECK(member)                                         \
                                                                            \
template&lt;typename T, typename = std::true_type&gt;                             \
struct Alias_##member;                                                      \
                                                                            \
template&lt;typename T&gt;                                                        \
struct Alias_##member &lt;                                                     \
    T, std::integral_constant&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;::value&gt;  \
&gt; { static const decltype(&amp;T::member) value; };                             \
                                                                            \
struct AmbiguitySeed_##member { char member; };                             \
                                                                            \
template&lt;typename T&gt;                                                        \
struct has_member_##member {                                                \
    static const bool value                                                 \
        = has_member&lt;                                                       \
            Alias_##member&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;&gt;            \
            , Alias_##member&lt;AmbiguitySeed_##member&gt;                        \
        &gt;::value                                                            \
    ;                                                                       \
}
</code></pre>

<p><strong>CREATE_MEMBER_VAR_CHECK:</strong></p>

<pre><code>//Check for member variable with given name.
#define CREATE_MEMBER_VAR_CHECK(var_name)                                   \
                                                                            \
template&lt;typename T, typename = std::true_type&gt;                             \
struct has_member_var_##var_name : std::false_type {};                      \
                                                                            \
template&lt;typename T&gt;                                                        \
struct has_member_var_##var_name&lt;                                           \
    T                                                                       \
    , std::integral_constant&lt;                                               \
        bool                                                                \
        , !std::is_member_function_pointer&lt;decltype(&amp;T::var_name)&gt;::value   \
    &gt;                                                                       \
&gt; : std::true_type {}
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_SIG_CHECK:</strong></p>

<pre><code>//Check for member function with given name AND signature.
#define CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \
                                                                            \
template&lt;typename T, typename = std::true_type&gt;                             \
struct has_member_func_##templ_postfix : std::false_type {};                \
                                                                            \
template&lt;typename T&gt;                                                        \
struct has_member_func_##templ_postfix&lt;                                     \
    T, std::integral_constant&lt;                                              \
        bool                                                                \
        , sig_check&lt;func_sig, &amp;T::func_name&gt;::value                         \
    &gt;                                                                       \
&gt; : std::true_type {}
</code></pre>

<p><strong>CREATE_MEMBER_CLASS_CHECK:</strong></p>

<pre><code>//Check for member class with given name.
#define CREATE_MEMBER_CLASS_CHECK(class_name)               \
                                                            \
template&lt;typename T, typename = std::true_type&gt;             \
struct has_member_class_##class_name : std::false_type {};  \
                                                            \
template&lt;typename T&gt;                                        \
struct has_member_class_##class_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_class&lt;                                    \
            typename got_type&lt;typename T::class_name&gt;::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}
</code></pre>

<p><strong>CREATE_MEMBER_UNION_CHECK:</strong></p>

<pre><code>//Check for member union with given name.
#define CREATE_MEMBER_UNION_CHECK(union_name)               \
                                                            \
template&lt;typename T, typename = std::true_type&gt;             \
struct has_member_union_##union_name : std::false_type {};  \
                                                            \
template&lt;typename T&gt;                                        \
struct has_member_union_##union_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_union&lt;                                    \
            typename got_type&lt;typename T::union_name&gt;::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}
</code></pre>

<p><strong>CREATE_MEMBER_ENUM_CHECK:</strong></p>

<pre><code>//Check for member enum with given name.
#define CREATE_MEMBER_ENUM_CHECK(enum_name)                 \
                                                            \
template&lt;typename T, typename = std::true_type&gt;             \
struct has_member_enum_##enum_name : std::false_type {};    \
                                                            \
template&lt;typename T&gt;                                        \
struct has_member_enum_##enum_name&lt;                         \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_enum&lt;                                     \
            typename got_type&lt;typename T::enum_name&gt;::type  \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_CHECK:</strong></p>

<pre><code>//Check for function with given name, any signature.
#define CREATE_MEMBER_FUNC_CHECK(func)          \
template&lt;typename T&gt;                            \
struct has_member_func_##func {                 \
    static const bool value                     \
        = has_member_##func&lt;T&gt;::value           \
        &amp;&amp; !has_member_var_##func&lt;T&gt;::value     \
        &amp;&amp; !has_member_class_##func&lt;T&gt;::value   \
        &amp;&amp; !has_member_union_##func&lt;T&gt;::value   \
        &amp;&amp; !has_member_enum_##func&lt;T&gt;::value    \
    ;                                           \
}
</code></pre>

<p><strong>CREATE_MEMBER_CHECKS:</strong></p>

<pre><code>//Create all the checks for one member.  Does NOT include func sig checks.
#define CREATE_MEMBER_CHECKS(member)    \
CREATE_MEMBER_CHECK(member);            \
CREATE_MEMBER_VAR_CHECK(member);        \
CREATE_MEMBER_CLASS_CHECK(member);      \
CREATE_MEMBER_UNION_CHECK(member);      \
CREATE_MEMBER_ENUM_CHECK(member);       \
CREATE_MEMBER_FUNC_CHECK(member)
</code></pre>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>This should be sufficient, if you know the name of the member function you are expecting. (In this case, the function bla fails to instantiate if there is no member function (writing one that works anyway is tough because there is a lack of function partial specialization. You may need to use class templates) Also, the enable struct (which is similar to enable_if) could also be templated on the type of function you want it to have as a member.</p>

<pre><code>template &lt;typename T, int (T::*) ()&gt; struct enable { typedef T type; };
template &lt;typename T&gt; typename enable&lt;T, &amp;T::i&gt;::type bla (T&amp;);
struct A { void i(); };
struct B { int i(); };
int main()
{
  A a;
  B b;
  bla(b);
  bla(a);
}
</code></pre>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>With c++ 20 this becomes much simpler. Say we want to test if a class <code>T</code> has a member function <code>void T::resize(typename T::size_type)</code>. For example, <code>std::vector&lt;U&gt;</code> has such a member function. Then,</p>
<pre class="lang-cpp prettyprint-override"><code>template&lt;typename T&gt;
concept has_resize_member_func = requires {
    typename T::size_type;
    { std::declval&lt;T&gt;().resize(std::declval&lt;typename T::size_type&gt;()) } -&gt; std::same_as&lt;void&gt;;
};
</code></pre>
<p>and the usage is</p>
<pre class="lang-cpp prettyprint-override"><code>static_assert(has_resize_member_func&lt;std::string&gt;, "");
static_assert(has_resize_member_func&lt;int&gt; == false, "");
</code></pre>
    </div><div class="s-prose js-post-body" itemprop="text">
<p>Here is a simpler take on Mike Kinghan's answer. This will detect inherited methods. It will also check for the <em>exact</em> signature (unlike jrok's approach which allows argument conversions).</p>

<pre><code>template &lt;class C&gt;
class HasGreetMethod
{
    template &lt;class T&gt;
    static std::true_type testSignature(void (T::*)(const char*) const);

    template &lt;class T&gt;
    static decltype(testSignature(&amp;T::greet)) test(std::nullptr_t);

    template &lt;class T&gt;
    static std::false_type test(...);

public:
    using type = decltype(test&lt;C&gt;(nullptr));
    static const bool value = type::value;
};

struct A { void greet(const char* name) const; };
struct Derived : A { };
static_assert(HasGreetMethod&lt;Derived&gt;::value, "");
</code></pre>

<p>Runnable <a href="http://ideone.com/LjtMSi" rel="noreferrer">example</a></p>
    </div></body></html>